<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brochure Viewer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 10px;
            font-family: Arial, sans-serif;
            background-color: #f5f5f5;
            overflow: hidden;
        }
        #canvas-container {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #ffffff;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        #fabric-canvas {
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
        }
        #info-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.98);
            padding: 12px;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            max-width: 280px;
            font-size: 13px;
            z-index: 1000;
            border: 1px solid #e0e0e0;
        }
        #info-panel .close-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background: rgba(0, 0, 0, 0.1);
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            cursor: pointer;
            font-size: 16px;
            line-height: 1;
            color: #666;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        #info-panel .close-btn:hover {
            background: rgba(0, 0, 0, 0.2);
            color: #000;
        }
        .status-available { color: #4CAF50; font-weight: bold; }
        .status-booked { color: #2196F3; font-weight: bold; }
        .status-sold { color: #F44336; font-weight: bold; }
        .plot-info {
            margin: 5px 0;
            padding: 5px;
            border-bottom: 1px solid #eee;
        }
        .plot-info:last-child {
            border-bottom: none;
        }
        .status-selector {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 2px solid #e0e0e0;
        }
        .status-selector-title {
            font-weight: bold;
            margin-bottom: 8px;
            font-size: 12px;
            color: #333;
        }
        .status-btn {
            display: inline-block;
            padding: 8px 16px;
            margin: 4px 4px 4px 0;
            border: 2px solid;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: bold;
            transition: all 0.2s ease;
            background: white;
            min-width: 80px;
            text-align: center;
        }
        .status-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .status-btn.available {
            color: #4CAF50;
            border-color: #4CAF50;
        }
        .status-btn.available:hover {
            background: #4CAF50;
            color: white;
        }
        .status-btn.available.active {
            background: #4CAF50;
            color: white;
        }
        .status-btn.booked {
            color: #2196F3;
            border-color: #2196F3;
        }
        .status-btn.booked:hover {
            background: #2196F3;
            color: white;
        }
        .status-btn.booked.active {
            background: #2196F3;
            color: white;
        }
        .status-btn.sold {
            color: #F44336;
            border-color: #F44336;
        }
        .status-btn.sold:hover {
            background: #F44336;
            color: white;
        }
        .status-btn.sold.active {
            background: #F44336;
            color: white;
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <canvas id="fabric-canvas"></canvas>
    </div>
    <div id="info-panel" style="display: none;">
        <div id="plot-details"></div>
    </div>

    <script>
        // Parse plots data first to check if overlay exists
        let plotsData;
        try {
            plotsData = JSON.parse('{{PLOTS_DATA}}');
            // Log plot numbers for debugging
            console.log('ðŸ“Š Brochure viewer: Loaded', plotsData.length, 'plots');
            if (plotsData.length > 0) {
                console.log('First 5 plots:', plotsData.slice(0, 5).map(p => ({
                    id: p.id,
                    plot_number: p.plot_number,
                    status: p.status
                })));
            }
        } catch (e) {
            console.error('Error parsing plots data:', e);
            plotsData = [];
        }
        
        const backgroundImageUrl = '{{BACKGROUND_IMAGE_URL}}';
        const plotOverlayUrl = '{{PLOT_OVERLAY_URL}}' !== 'null' && '{{PLOT_OVERLAY_URL}}' !== '' ? '{{PLOT_OVERLAY_URL}}' : null;
        
        // Initialize Fabric.js canvas
        // Use a neutral background color that won't show white gaps
        const canvas = new fabric.Canvas('fabric-canvas', {
            width: 900,
            height: 600,
            backgroundColor: plotOverlayUrl ? '#f0f0f0' : '#ffffff',  // Neutral gray for colored backgrounds
            selection: false
        });
        
        // Configure image smoothing for sharp background rendering
        const canvasEl = canvas.getElement();
        const ctx = canvasEl.getContext('2d');
        ctx.imageSmoothingEnabled = true;  // Enable smoothing but with high quality
        ctx.imageSmoothingQuality = 'high';  // High quality to avoid blur
        
        // Make canvas available globally for parent window access
        window.fabricCanvas = canvas;
        
        // Store transform state globally
        window.currentScale = 1.0;
        window.currentOffsetX = 0;
        window.currentOffsetY = 0;
        window.currentRotation = 0;

        // Status color mapping - user-friendly colors
        const statusColors = {
            'available': '#4CAF50',   // Green for available
            'booked': '#2196F3',      // Blue for booked
            'sold': '#F44336'         // Red for sold
        };

        // Dark borders for better visibility - matching client's dark border style
        const statusBorders = {
            'available': '#424242',   // Dark gray - prominent borders
            'booked': '#424242',      // Dark gray - prominent borders
            'sold': '#424242'         // Dark gray - prominent borders
        };


        // Load background image
        fabric.Image.fromURL(backgroundImageUrl, function(bgImg) {
            // Always fit canvas (contain mode) to maintain aspect ratio and fit within frame
            // This ensures the background image is not enlarged beyond the canvas
            const hasOverlay = plotOverlayUrl !== null;
            
            // Fit canvas (maintain aspect ratio) - use Math.min to fit within frame
            const scale = Math.min(
                canvas.width / bgImg.width,
                canvas.height / bgImg.height
            );
            const bgLeft = (canvas.width - bgImg.width * scale) / 2;
            const bgTop = (canvas.height - bgImg.height * scale) / 2;
            
            bgImg.scale(scale);
            bgImg.set({
                left: bgLeft,
                top: bgTop,
                selectable: false,
                evented: false,
                opacity: 1.0  // Full opacity for background - fully visible
            });
            
            // Store background properties for overlay and plots
            window.bgScale = scale;
            window.bgLeft = bgLeft;
            window.bgTop = bgTop;
            window.bgWidth = bgImg.width;
            window.bgHeight = bgImg.height;
            
            // For colored backgrounds with overlay, add background as regular object for better visibility
            // For white backgrounds, use setBackgroundImage
            if (plotOverlayUrl) {
                // Add background as regular image object at the bottom for maximum visibility
                canvas.add(bgImg);
                canvas.sendToBack(bgImg);
                // Store reference for overlay positioning
                window.bgImgRef = bgImg;
            } else {
                // Set background image for white backgrounds
                canvas.setBackgroundImage(bgImg, canvas.renderAll.bind(canvas), {
                    scaleX: scale,
                    scaleY: scale,
                    left: bgLeft,
                    top: bgTop
                }, {
                    crossOrigin: 'anonymous'
                });
            }
            
            // Ensure background is fully visible
            canvas.renderAll();

            // Load overlay image only if provided (optional)
            if (plotOverlayUrl) {
                fabric.Image.fromURL(plotOverlayUrl, function(overlayImg) {
                    // Overlay must match background exactly - same scale, same position
                    // Calculate scale based on background dimensions to ensure alignment
                    const overlayScale = window.bgScale || scale;
                    const overlayLeft = window.bgLeft !== undefined ? window.bgLeft : bgLeft;
                    const overlayTop = window.bgTop !== undefined ? window.bgTop : bgTop;
                    
                    // Scale overlay to match background's scaled dimensions
                    // If overlay has different original dimensions, scale proportionally
                    const bgScaledWidth = (window.bgWidth || bgImg.width) * overlayScale;
                    const bgScaledHeight = (window.bgHeight || bgImg.height) * overlayScale;
                    const overlayScaleX = bgScaledWidth / overlayImg.width;
                    const overlayScaleY = bgScaledHeight / overlayImg.height;
                    
                    overlayImg.scaleX = overlayScaleX;
                    overlayImg.scaleY = overlayScaleY;
                    overlayImg.set({
                        left: overlayLeft,
                        top: overlayTop,
                        selectable: false,
                        evented: false,
                        opacity: 0.2  // Very transparent so background is clearly visible
                    });
                    canvas.add(overlayImg);
                    // Position overlay above background but below plot polygons
                    // Background is already at the back, so overlay goes above it
                    const bgImgRef = window.bgImgRef;
                    if (bgImgRef) {
                        const bgIndex = canvas.getObjects().indexOf(bgImgRef);
                        if (bgIndex >= 0) {
                            canvas.moveTo(overlayImg, bgIndex + 1);
                        } else {
                            canvas.sendToBack(overlayImg);
                        }
                    } else {
                        canvas.sendToBack(overlayImg);
                    }
                    
                    // Force re-render to ensure background is visible
                    canvas.renderAll();

                    // Add plot polygons after overlay loads - use full scale, no reduction
                    addPlotPolygons(overlayScale, overlayLeft, overlayTop, true);
                }, {
                    crossOrigin: 'anonymous'
                });
            } else {
                // Add plot polygons directly if no overlay
                addPlotPolygons(scale, bgLeft, bgTop, false);
            }
        });

        function addPlotPolygons(scale, offsetX, offsetY, hasOverlay) {
            // Use background scale if available, otherwise use provided scale
            const plotScale = window.bgScale || scale;
            let plotOffsetX = window.bgLeft !== undefined ? window.bgLeft : offsetX;
            let plotOffsetY = window.bgTop !== undefined ? window.bgTop : offsetY;
            
            // Always use full scale to match background image dimensions exactly
            // Since we always use the uploaded image as background, plots should match it perfectly
            const plotScaleFactor = plotScale;
            
            // Array to collect all polygons before grouping
            const plotPolygonsArray = [];
            
            // Scale and position plots to match background image exactly
            // No centering - plots should align with background image at the same scale and offset
            plotsData.forEach((plot, index) => {
                if (!plot.points || plot.points.length < 3) {
                    return;
                }

                // Scale and offset points to match background image exactly
                // point.x and point.y are in original image pixel coordinates
                // Scale them by plotScaleFactor and add background offset to match background image position
                const points = plot.points.map(point => ({
                    x: (point.x * plotScaleFactor) + plotOffsetX,
                    y: (point.y * plotScaleFactor) + plotOffsetY
                }));
                
                // Validate that points are within canvas bounds
                const validPoints = points.filter(p => 
                    p.x >= 0 && p.x <= canvas.width && 
                    p.y >= 0 && p.y <= canvas.height
                );
                
                if (validPoints.length < 3) {
                    console.warn('Plot', plot.id, 'has points outside canvas bounds, skipping');
                    return;
                }
                
                // Use valid points for polygon creation
                const finalPoints = validPoints.length === points.length ? points : validPoints;

                // Create polygon with dark borders and visible fill - matching client's style
                const polygon = new fabric.Polygon(finalPoints, {
                    fill: statusColors[plot.status] || statusColors['available'],
                    stroke: statusBorders[plot.status] || statusBorders['available'],
                    strokeWidth: 2,  // Thinner borders for cleaner look
                    opacity: 1,      // Full opacity
                    selectable: false,
                    hoverCursor: 'pointer',
                    plotId: plot.id,
                    plotData: plot,
                    strokeLineJoin: 'miter',  // Sharp corners
                    strokeLineCap: 'butt',    // Clean line ends
                    objectCaching: false      // Better performance for many plots
                });

                // Store original values for hover restoration
                const originalFill = polygon.fill;
                const originalStrokeWidth = polygon.strokeWidth;
                const originalStroke = polygon.stroke;

                // Enhanced hover effect - visual feedback only (don't show info panel on hover)
                polygon.on('mouseover', function() {
                    // Only show visual feedback, don't show info panel on hover
                    // Check if this plot is not already selected
                    if (currentSelectedPlot && currentSelectedPlot.id === plot.id) {
                        return; // Already selected, don't change appearance
                    }
                    // Increase border thickness on hover for visual feedback
                    this.set({
                        strokeWidth: 3,             // Slightly thicker border on hover
                        stroke: '#212121'          // Dark border on hover
                    });
                    canvas.renderAll();
                });

                polygon.on('mouseout', function() {
                    // Only restore if this plot is not currently selected
                    if (currentSelectedPlot && currentSelectedPlot.id === plot.id) {
                        return; // Keep selected appearance
                    }
                    // Restore original appearance
                    this.set({
                        strokeWidth: originalStrokeWidth,
                        stroke: originalStroke
                    });
                    canvas.renderAll();
                });

                // Add click handler to show status selector and keep it open
                polygon.on('mousedown', function() {
                    console.log('Plot clicked:', plot.id, plot);
                    // If clicking the same plot, toggle the panel
                    if (currentSelectedPlot && currentSelectedPlot.id === plot.id) {
                        hidePlotInfo();
                        // Restore original appearance
                        this.set({
                            fill: originalFill,
                            strokeWidth: originalStrokeWidth,
                            stroke: originalStroke
                        });
                        canvas.renderAll();
                    } else {
                        // Restore previous selected plot appearance if any
                        if (currentSelectedPolygon) {
                            const prevPlot = currentSelectedPlot;
                            const prevPolygon = currentSelectedPolygon;
                            const prevOriginalFill = statusColors[prevPlot.status] || statusColors['available'];
                            prevPolygon.set({
                                fill: prevOriginalFill,
                                strokeWidth: originalStrokeWidth,
                                stroke: originalStroke
                            });
                        }
                        // Show info panel for clicked plot (stays open until another plot is clicked or same plot is clicked again)
                        showPlotInfo(plot, polygon);
                        // Update clicked plot appearance to show it's selected (thicker border)
                        this.set({
                            strokeWidth: 3,
                            stroke: '#212121'
                        });
                        canvas.renderAll();
                    }
                });
                
                // Store polygon reference for status updates
                window.plotPolygons = window.plotPolygons || {};
                window.plotPolygons[plot.id] = polygon;

                // Add polygon to canvas first to ensure correct positioning
                canvas.add(polygon);
                plotPolygonsArray.push(polygon);
            });

            // After all polygons are added and positioned correctly, group them
            if (plotPolygonsArray.length > 0) {
                // Check if group already exists in canvas (to avoid recreating on rerun)
                const existingGroup = canvas.getObjects().find(obj => 
                    obj.type === 'group' && 
                    obj._objects && 
                    obj._objects.length > 0 && 
                    obj._objects.some(o => o.plotId)
                );
                
                if (existingGroup) {
                    // Reuse existing group
                    window.plotGroup = existingGroup;
                    console.log('Reusing existing plot group with', existingGroup._objects.length, 'polygons');
                } else {
                    // Remove old group reference if it exists but isn't in canvas
                    if (window.plotGroup && !canvas.getObjects().includes(window.plotGroup)) {
                        window.plotGroup = null;
                    }
                    
                    // Remove polygons from canvas to group them
                    plotPolygonsArray.forEach(polygon => {
                        canvas.remove(polygon);
                    });
                    
                    // Create group directly - Fabric.js handles positioning automatically
                    window.plotGroup = new fabric.Group(plotPolygonsArray, {
                        selectable: false,
                        originX: 'center',
                        originY: 'center',
                        objectCaching: false,
                        evented: true
                    });
                    
                    // Store original position (Fabric.js calculated this automatically)
                    window.plotGroup.originalLeft = window.plotGroup.left;
                    window.plotGroup.originalTop = window.plotGroup.top;
                    window.plotGroup.originalScaleX = 1.0;
                    window.plotGroup.originalScaleY = 1.0;
                    window.plotGroup.originalAngle = 0;
                    
                    // Add group to canvas
                    canvas.add(window.plotGroup);
                    
                    console.log('Created plot group with', plotPolygonsArray.length, 'polygons at', window.plotGroup.left, window.plotGroup.top);
                }
                
                // Add event handlers to the group to detect plot clicks
                if (window.plotGroup) {
                    console.log('Adding event handlers to group with', window.plotGroup.getObjects().length, 'polygons');
                    console.log('Brochure canvas found with', window.plotGroup.getObjects().length, 'plots!');
                    
                    // Handle mouseover on group - find which polygon
                    window.plotGroup.on('mousemove', function(e) {
                        const pointer = canvas.getPointer(e.e);
                        const groupObjects = window.plotGroup.getObjects();
                        
                        // Find polygon under pointer
                        for (let i = 0; i < groupObjects.length; i++) {
                            const obj = groupObjects[i];
                            if (obj.plotId && obj.plotData) {
                                // Convert pointer to group coordinates
                                const groupPointer = fabric.util.transformPoint(
                                    pointer,
                                    fabric.util.invertTransform(window.plotGroup.calcTransformMatrix())
                                );
                                
                                // Check if pointer is inside polygon
                                if (obj.containsPoint(groupPointer)) {
                                    // Visual feedback
                                    obj.set({
                                        strokeWidth: 3,
                                        stroke: '#212121'
                                    });
                                    canvas.renderAll();
                                    return;
                                } else {
                                    // Restore if not hovered
                                    if (!(currentSelectedPlot && currentSelectedPlot.id === obj.plotData.id)) {
                                        obj.set({
                                            strokeWidth: 2,
                                            stroke: statusBorders[obj.plotData.status] || '#424242'
                                        });
                                    }
                                }
                            }
                        }
                        canvas.renderAll();
                    });
                    
                    // Handle click on group - find which polygon was clicked
                    window.plotGroup.on('mousedown', function(e) {
                        const pointer = canvas.getPointer(e.e);
                        const groupObjects = window.plotGroup.getObjects();
                        
                        console.log('Group clicked, checking', groupObjects.length, 'polygons');
                        
                        // Find polygon under pointer
                        for (let i = 0; i < groupObjects.length; i++) {
                            const obj = groupObjects[i];
                            if (obj.plotId && obj.plotData) {
                                // Convert pointer to group coordinates
                                const groupPointer = fabric.util.transformPoint(
                                    pointer,
                                    fabric.util.invertTransform(window.plotGroup.calcTransformMatrix())
                                );
                                
                                // Check if pointer is inside polygon
                                if (obj.containsPoint(groupPointer)) {
                                    console.log('Clicked on plot:', obj.plotData.id);
                                    
                                    // If clicking the same plot, toggle the panel
                                    if (currentSelectedPlot && currentSelectedPlot.id === obj.plotData.id) {
                                        hidePlotInfo();
                                        // Restore original appearance
                                        obj.set({
                                            strokeWidth: 2,
                                            stroke: statusBorders[obj.plotData.status] || '#424242'
                                        });
                                    } else {
                                        // Restore previous selected plot appearance if any
                                        if (currentSelectedPolygon) {
                                            const prevPlot = currentSelectedPlot;
                                            currentSelectedPolygon.set({
                                                strokeWidth: 2,
                                                stroke: statusBorders[prevPlot.status] || '#424242'
                                            });
                                        }
                                        
                                        // Show info panel for clicked plot
                                        showPlotInfo(obj.plotData, obj);
                                        
                                        // Update clicked plot appearance to show it's selected
                                        obj.set({
                                            strokeWidth: 3,
                                            stroke: '#212121'
                                        });
                                    }
                                    
                                    canvas.renderAll();
                                    return; // Stop after finding the first match
                                }
                            }
                        }
                    });
                }
            }

            canvas.renderAll();
            
            // Make applyTransform function available globally - now scales the GROUP
            window.applyBrochureTransform = function() {
                const scale = window.currentScale || 1.0;
                const offsetX = window.currentOffsetX || 0;
                const offsetY = window.currentOffsetY || 0;
                const rotation = window.currentRotation || 0;
                
                console.log('applyBrochureTransform called with:', {scale, offsetX, offsetY, rotation});
                
                // Get or find the plot group
                let plotGroup = window.plotGroup;
                if (!plotGroup) {
                    // Try to find existing group in canvas
                    const allObjects = canvas.getObjects();
                    plotGroup = allObjects.find(obj => obj.type === 'group' && obj._objects && obj._objects.some(o => o.plotId));
                    if (plotGroup) {
                        window.plotGroup = plotGroup;
                        // Store original properties if not already stored
                        if (!plotGroup.originalLeft) {
                            plotGroup.originalLeft = plotGroup.left;
                            plotGroup.originalTop = plotGroup.top;
                            plotGroup.originalScaleX = plotGroup.scaleX || 1.0;
                            plotGroup.originalScaleY = plotGroup.scaleY || 1.0;
                            plotGroup.originalAngle = plotGroup.angle || 0;
                        }
                    }
                }
                
                if (!plotGroup) {
                    console.warn('Plot group not found, cannot apply transform');
                    return;
                }
                
                // Ensure original properties are stored
                if (plotGroup.originalLeft === undefined) {
                    plotGroup.originalLeft = plotGroup.left;
                    plotGroup.originalTop = plotGroup.top;
                    plotGroup.originalScaleX = 1.0;
                    plotGroup.originalScaleY = 1.0;
                    plotGroup.originalAngle = 0;
                }
                
                // Apply scale to the group (this scales all polygons together as one unit)
                plotGroup.set({
                    scaleX: scale,
                    scaleY: scale,
                    angle: rotation,
                    left: plotGroup.originalLeft + offsetX,
                    top: plotGroup.originalTop + offsetY
                });
                
                plotGroup.setCoords();
                canvas.renderAll();
                
                console.log('Group transform applied - scale:', scale, 'rotation:', rotation, 'offset:', offsetX, offsetY);
            };
        }

        // Store current selected plot and polygon
        let currentSelectedPlot = null;
        let currentSelectedPolygon = null;
        
        function showPlotInfo(plot, polygon) {
            const infoPanel = document.getElementById('info-panel');
            const plotDetails = document.getElementById('plot-details');
            
            currentSelectedPlot = plot;
            currentSelectedPolygon = polygon;
            
            // Get plot number for display - should match the number in plot.id
            // Use plot_number if available (this is the source of truth after renumbering)
            let displayPlotNumber = plot.plot_number;
            if (displayPlotNumber === null || displayPlotNumber === undefined || displayPlotNumber === 0) {
                // Fallback: Extract number from plot.id (e.g., "Plot 1" -> 1)
                const idMatch = String(plot.id).match(/(\d+)/);
                if (idMatch) {
                    displayPlotNumber = parseInt(idMatch[1]);
                } else {
                    displayPlotNumber = plot.id;  // Fallback to full ID if no number found
                }
            }
            
            let html = `<button class="close-btn" onclick="hidePlotInfo()" title="Close">Ã—</button>
                <div class="plot-info">
                <strong>Plot Number:</strong> ${displayPlotNumber}<br>
                <strong>Plot ID:</strong> ${plot.id}<br>
                <strong>Current Status:</strong> <span class="status-${plot.status}">${plot.status}</span><br>`;
            
            if (plot.lat !== null && plot.lat !== undefined && 
                plot.lon !== null && plot.lon !== undefined) {
                html += `<strong>Location:</strong><br>
                    Lat: ${plot.lat.toFixed(6)}<br>
                    Lon: ${plot.lon.toFixed(6)}<br>`;
            }
            
            // Add status selector
            html += `<div class="status-selector">
                <div class="status-selector-title">Change Status:</div>
                <button class="status-btn available ${plot.status === 'available' ? 'active' : ''}" 
                        onclick="updatePlotStatus('available')">
                    ðŸŸ¢ Available
                </button>
                <button class="status-btn booked ${plot.status === 'booked' ? 'active' : ''}" 
                        onclick="updatePlotStatus('booked')">
                    ðŸ”µ Booked
                </button>
                <button class="status-btn sold ${plot.status === 'sold' ? 'active' : ''}" 
                        onclick="updatePlotStatus('sold')">
                    ðŸ”´ Sold
                </button>
            </div></div>`;
            
            plotDetails.innerHTML = html;
            infoPanel.style.display = 'block';
        }
        
        function hidePlotInfo() {
            const infoPanel = document.getElementById('info-panel');
            infoPanel.style.display = 'none';
            
            // Restore selected plot appearance
            if (currentSelectedPolygon && currentSelectedPlot) {
                const plot = currentSelectedPlot;
                const originalFill = statusColors[plot.status] || statusColors['available'];
                const originalStroke = statusBorders[plot.status] || statusBorders['available'];
                currentSelectedPolygon.set({
                    fill: originalFill,
                    strokeWidth: 2,
                    stroke: originalStroke
                });
                
                // If polygon is in a group, mark group as dirty
                if (window.plotGroup) {
                    window.plotGroup.dirty = true;
                }
                
                canvas.renderAll();
            }
            
            currentSelectedPlot = null;
            currentSelectedPolygon = null;
        }
        
        // Function to update plot status
        function updatePlotStatus(newStatus) {
            if (!currentSelectedPlot || !currentSelectedPolygon) {
                return;
            }
            
            const plotId = currentSelectedPlot.id;
            const oldStatus = currentSelectedPlot.status;
            
            // Don't update if status is the same
            if (oldStatus === newStatus) {
                return;
            }
            
            // Update plot data
            currentSelectedPlot.status = newStatus;
            
            // Update polygon color
            const newColor = statusColors[newStatus] || statusColors['available'];
            const newBorder = statusBorders[newStatus] || statusBorders['available'];
            currentSelectedPolygon.set({
                fill: newColor,
                stroke: newBorder
            });
            
            // Update the plotData reference so hover/click logic uses new status
            if (currentSelectedPolygon.plotData) {
                currentSelectedPolygon.plotData.status = newStatus;
            }
            
            // If polygon is in a group, mark group as dirty to force re-render
            if (window.plotGroup) {
                window.plotGroup.dirty = true;
            }
            
            canvas.renderAll();
            
            // Send status update to parent (Streamlit)
            try {
                if (window.parent) {
                    window.parent.postMessage({
                        type: 'plot_status_update',
                        plotId: plotId,
                        newStatus: newStatus,
                        oldStatus: oldStatus,
                        timestamp: Date.now()
                    }, '*');
                }
            } catch (e) {
                console.error('Failed to send status update:', e);
            }
            
            // Update the info panel to reflect new status
            showPlotInfo(currentSelectedPlot, currentSelectedPolygon);
            
            console.log(`Plot ${plotId} status updated from ${oldStatus} to ${newStatus}`);
        }
        
        // Make functions available globally
        window.updatePlotStatus = updatePlotStatus;
        window.hidePlotInfo = hidePlotInfo;
        window.showPlotInfo = showPlotInfo;


        // Handle canvas resize
        function resizeCanvas() {
            const container = document.getElementById('canvas-container');
            const containerWidth = container.clientWidth - 20;
            const containerHeight = window.innerHeight - 20;
            
            canvas.setDimensions({
                width: containerWidth,
                height: containerHeight
            });
            
            // Re-apply image smoothing settings after resize
            const canvasEl = canvas.getElement();
            const ctx = canvasEl.getContext('2d');
            ctx.imageSmoothingEnabled = true;  // Enable smoothing but with high quality
            ctx.imageSmoothingQuality = 'high';  // High quality to avoid blur
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
    </script>
</body>
</html>
 
