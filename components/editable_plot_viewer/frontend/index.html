<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Editable Plot Viewer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 10px;
            font-family: Arial, sans-serif;
            background-color: #f5f5f5;
            overflow: auto;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        #canvas-container {
            width: 100%;
            flex: 1;
            min-height: 600px;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            position: relative;
            overflow: auto; /* Allow scrolling if content is larger */
            margin-top: 0;
        }
        #loading-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #666;
            font-size: 16px;
            z-index: 1;
        }
        #info-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.98);
            padding: 12px;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            max-width: 280px;
            font-size: 13px;
            z-index: 1000;
            border: 1px solid #e0e0e0;
        }
        .button-container {
            display: flex;
            flex-direction: row;
            gap: 10px;
            padding: 10px;
            justify-content: flex-end;
            background-color: #f5f5f5;
            margin-bottom: 0;
            border-bottom: 1px solid #ddd;
            flex-shrink: 0;
        }
        .zoom-controls-simple {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 1000;
        }
        .zoom-btn-simple {
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid #2196F3;
            border-radius: 4px;
            font-size: 20px;
            font-weight: bold;
            color: #2196F3;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .zoom-btn-simple:hover {
            background: #2196F3;
            color: white;
        }
        .zoom-btn-simple:active {
            transform: scale(0.95);
        }
        .zoom-controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: center;
        }
        .help-tooltip {
            position: absolute;
            bottom: 120px;
            right: 20px;
            background: rgba(76, 175, 80, 0.95);
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 1001;
            font-size: 13px;
            max-width: 280px;
            animation: fadeIn 0.5s ease-in;
        }
        .help-tooltip .close-tooltip {
            position: absolute;
            top: 5px;
            right: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 16px;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .zoom-controls h4 {
            margin: 0;
            font-size: 13px;
            color: #333;
        }
        .zoom-buttons {
            display: flex;
            gap: 5px;
            align-items: center;
        }
        .zoom-btn {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: #f5f5f5;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            min-width: 40px;
            user-select: none;
        }
        .zoom-btn:hover {
            background: #e0e0e0;
        }
        .zoom-btn:active {
            background: #d0d0d0;
        }
        .zoom-value {
            font-size: 12px;
            color: #666;
            margin-top: 2px;
        }
        .save-button, .merge-button, .create-button, .delete-button {
            padding: 10px 20px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            white-space: nowrap;
        }
        .save-button {
            background-color: #007bff;  /* Primary blue */
        }
        .save-button:hover {
            background-color: #0056b3;
        }
        .merge-button {
            background-color: #ffc107;  /* Warning orange */
        }
        .merge-button:hover {
            background-color: #e0a800;
        }
        .create-button {
            background-color: #28a745;  /* Success green */
        }
        .create-button:hover {
            background-color: #218838;
        }
        .delete-button {
            background-color: #dc3545;  /* Danger red */
        }
        .delete-button:hover {
            background-color: #c82333;
        }
        .number-dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            z-index: 10000;
            min-width: 300px;
            text-align: center;
        }
        .number-dialog h3 {
            margin-top: 0;
            color: #333;
        }
        .number-dialog input {
            width: 100px;
            padding: 10px;
            font-size: 18px;
            text-align: center;
            border: 2px solid #4CAF50;
            border-radius: 4px;
            margin: 15px 0;
        }
        .number-dialog .button-group {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }
        .number-dialog button {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
        }
        .number-dialog .confirm-btn {
            background-color: #4CAF50;
            color: white;
        }
        .number-dialog .confirm-btn:hover {
            background-color: #45a049;
        }
        .number-dialog .cancel-btn {
            background-color: #f44336;
            color: white;
        }
        .number-dialog .cancel-btn:hover {
            background-color: #d32f2f;
        }
        .dialog-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 9999;
        }
        /* Pixel Move Dialog */
        #pixel-move-dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            z-index: 10001;
            min-width: 350px;
        }
        #pixel-move-dialog h3 {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 18px;
        }
        #pixel-move-dialog .info-text {
            color: #666;
            font-size: 13px;
            margin-bottom: 15px;
            line-height: 1.4;
        }
        #pixel-move-dialog .input-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        #pixel-move-dialog .input-group {
            flex: 1;
        }
        #pixel-move-dialog label {
            display: block;
            font-size: 12px;
            color: #555;
            margin-bottom: 5px;
            font-weight: bold;
        }
        #pixel-move-dialog input {
            width: 100%;
            padding: 10px;
            font-size: 16px;
            text-align: center;
            border: 2px solid #2196F3;
            border-radius: 6px;
            box-sizing: border-box;
        }
        #pixel-move-dialog .button-group {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
        }
        #pixel-move-dialog .apply-btn {
            background-color: #2196F3;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
        }
        #pixel-move-dialog .apply-btn:hover {
            background-color: #1976D2;
        }
        #pixel-move-dialog .cancel-btn {
            background-color: #e0e0e0;
            color: #333;
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
        }
        #pixel-move-dialog .cancel-btn:hover {
            background-color: #bdbdbd;
        }
        .selected-dot {
            stroke: #4CAF50 !important;
            stroke-width: 4 !important;
        }
    </style>
</head>
<body>
    <div class="button-container">
        <button class="save-button" id="save-btn">Save</button>
        <button class="merge-button" id="merge-btn">Merge</button>
        <button class="create-button" id="create-btn">Create</button>
        <button class="delete-button" id="delete-btn">Delete</button>
        <button class="save-button" id="move-dots-btn" style="background-color: #17a2b8;" title="Ctrl+Click on dots to select them (green), then click this button">Move</button>
    </div>
    <div id="canvas-container">
        <div id="loading-message">Loading image and plots...</div>
        <canvas id="fabric-canvas"></canvas>
        <!-- Zoom Controls -->
        <div class="zoom-controls">
            <h4> Zoom Controls</h4>
            <div class="zoom-buttons">
                <button class="zoom-btn" id="zoom-out-btn">‚àí</button>
                <button class="zoom-btn" id="zoom-in-btn">+</button>
            </div>
            <div class="zoom-value" id="zoom-value">1.0x</div>
            <div id="zoom-hint" style="font-size: 10px; color: #999; margin-top: 3px; text-align: center;">Zooms entire canvas<br>All layers stay together</div>
        </div>
    </div>
    <div id="info-panel" style="display: none;">
        <div id="plot-details"></div>
    </div>
    
    <!-- Help Tooltip -->
    <div class="help-tooltip" id="help-tooltip" style="display: none;">
        <span class="close-tooltip" onclick="document.getElementById('help-tooltip').style.display='none'">√ó</span>
        <strong>üí° Quick Tips:</strong><br>
        <small>
        ‚Ä¢ <strong>Ctrl+Click</strong> on dots to select (turns <span style="color: #90EE90;">green</span>)<br>
        ‚Ä¢ <strong>Zoom in</strong> then <strong>drag canvas</strong> to pan<br>
        ‚Ä¢ <strong>Esc</strong> to clear selection
        </small>
    </div>
    
    <!-- Number Input Dialog -->
    <div id="number-dialog-overlay" class="dialog-overlay" style="display: none;">
        <div class="number-dialog">
            <h3>Assign Plot Number</h3>
            <p id="number-dialog-message" style="color: #666; font-size: 14px;">Enter the plot number. Other plots will be automatically renumbered.</p>
            <input type="number" id="plot-number-input" min="1" value="1" />
            <div class="button-group">
                <button class="confirm-btn" id="confirm-number-btn">Confirm</button>
                <button class="cancel-btn" id="cancel-number-btn">Cancel</button>
            </div>
        </div>
    </div>
    
    <!-- Delete Confirmation Dialog -->
    <div id="delete-dialog-overlay" class="dialog-overlay" style="display: none;">
        <div class="number-dialog">
            <h3>‚ö†Ô∏è Confirm Delete</h3>
            <p id="delete-dialog-message" style="color: #666; font-size: 14px; margin: 15px 0;">Are you sure you want to delete this plot?<br><strong id="delete-plot-info" style="color: #f44336;"></strong><br>This action cannot be undone.</p>
            <div class="button-group">
                <button class="confirm-btn" id="confirm-delete-btn" style="background-color: #f44336;">Yes, Delete</button>
                <button class="cancel-btn" id="cancel-delete-btn">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Pixel Move Dialog -->
    <div id="pixel-move-overlay" class="dialog-overlay" style="display: none;">
        <div id="pixel-move-dialog">
            <div class="input-row">
                <div class="input-group">
                    <label for="move-dx">dx</label>
                    <input type="number" id="move-dx" value="0" step="1">
                </div>
                <div class="input-group">
                    <label for="move-dy">dy</label>
                    <input type="number" id="move-dy" value="0" step="1">
                </div>
            </div>
            <div class="button-group">
                <button class="cancel-btn" id="cancel-move-btn">Cancel</button>
                <button class="apply-btn" id="apply-move-btn">Apply</button>
            </div>
        </div>
    </div>

    <script>
        // Initialize Fabric.js canvas with proper dimensions
        const container = document.getElementById('canvas-container');
        const initialWidth = container ? Math.max(container.clientWidth - 20, 800) : 1000;
        const initialHeight = container ? Math.max(container.clientHeight - 20, 600) : 650;
        
        console.log('Initializing canvas with dimensions:', initialWidth, 'x', initialHeight);
        
        const canvas = new fabric.Canvas('fabric-canvas', {
            width: initialWidth,
            height: initialHeight,
            backgroundColor: '#ffffff',
            selection: true,
            allowTouchScrolling: false,
            renderOnAddRemove: true,
            stateful: false,  // Disable stateful caching for accurate coordinates
            preserveObjectStacking: true  // Preserve object order for proper layering
        });
        
        // CRITICAL: Disable object caching globally to prevent selection offset
        if (fabric.Object && fabric.Object.prototype) {
            fabric.Object.prototype.objectCaching = false;
            fabric.Object.prototype.statefullCache = false;
            fabric.Object.prototype.noScaleCache = true;
        }
        
        // Ensure canvas element dimensions match DOM size exactly
        const canvasEl = canvas.getElement();
        if (canvasEl) {
            canvasEl.width = initialWidth;
            canvasEl.height = initialHeight;
            canvasEl.style.width = initialWidth + 'px';
            canvasEl.style.height = initialHeight + 'px';
        }
        
        // CRITICAL: Recalculate offset to ensure pointer calculations respect zoom/pan
        canvas.calcOffset();
        
        // Pan/drag support when zoomed - synchronized movement for all layers
        let isPanning = false;
        let lastPosX = 0;
        let lastPosY = 0;
        
        canvas.on('mouse:down', function(opt) {
            const evt = opt.e;
            
            // If clicking on empty space without Ctrl (and not in special modes), clear selections
            if (!opt.target && !evt.ctrlKey && !evt.metaKey && !createMode && !mergeMode && !deleteMode) {
                // Clear plot selection when clicking empty canvas
                if (selectedPlotForDelete) {
                    clearPlotSelection();
                }
                // Clear dot selection
                if (selectedDotsForMove.length > 0) {
                    clearDotSelection();
                }
            }
            
            // Enable panning only when zoomed and clicking on empty space (not on objects)
            if (canvasViewZoom > 1.0 && !opt.target && !createMode && !mergeMode && !deleteMode) {
                isPanning = true;
                canvas.selection = false;
                lastPosX = evt.clientX;
                lastPosY = evt.clientY;
                canvas.defaultCursor = 'grab';
                canvas.setCursor('grabbing');
            }
        });
        
        canvas.on('mouse:move', function(opt) {
            if (isPanning && canvasViewZoom > 1.0) {
                const evt = opt.e;
                
                // Calculate movement delta
                const deltaX = evt.clientX - lastPosX;
                const deltaY = evt.clientY - lastPosY;
                
                // Skip if no movement
                if (deltaX === 0 && deltaY === 0) return;
                
                // Disable rendering during batch update for performance
                canvas.renderOnAddRemove = false;
                
                // Move ALL objects (including background) in one unified batch
                const allObjects = canvas.getObjects();
                for (let i = 0; i < allObjects.length; i++) {
                    const obj = allObjects[i];
                    obj.left += deltaX;
                    obj.top += deltaY;
                    obj.setCoords();
                    
                    // Update original position for zoom reference
                    if (obj.originalLeft !== undefined) {
                        obj.originalLeft += deltaX;
                        obj.originalTop += deltaY;
                    }
                }
                
                // Re-enable rendering and render once
                canvas.renderOnAddRemove = true;
                
                // CRITICAL: Recalculate canvas offset after panning to ensure pointer calculations remain accurate
                canvas.calcOffset();
                
                // CRITICAL: Update all object coordinates to ensure selection boxes align correctly after panning
                canvas.getObjects().forEach(obj => {
                    obj.setCoords();
                });
                
                canvas.requestRenderAll();
                
                // Update last position
                lastPosX = evt.clientX;
                lastPosY = evt.clientY;
                
                evt.preventDefault();
                evt.stopPropagation();
            }
        });
        
        canvas.on('mouse:up', function(opt) {
            if (isPanning) {
                isPanning = false;
                canvas.selection = true;
                canvas.defaultCursor = 'default';
                canvas.setCursor('default');
                canvas.renderAll();
            }
        });
        
        // Update cursor when hovering - show grab cursor when zoomed and over empty space
        canvas.on('mouse:over', function(opt) {
            if (canvasViewZoom > 1.0 && !opt.target && !createMode && !mergeMode && !deleteMode && !isPanning) {
                canvas.setCursor('grab');
            }
        });
        
        // Escape key to clear selections and cancel create mode
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                // If in create mode, cancel it (clear newly created points)
                if (createMode && newPlotPoints.length > 0) {
                    // Clear all newly created points
                    newPlotPoints.forEach(point => canvas.remove(point));
                    newPlotPoints = [];
                    selectedExistingCircles = [];
                    updateCreateButtonText();
                    canvas.renderAll();
                    console.log('Create mode cancelled via Escape key');
                }
                // Clear plot selection first
                if (selectedPlotForDelete) {
                    clearPlotSelection();
                }
                // Clear dot selection
                if (selectedDotsForMove.length > 0) {
                    clearDotSelection();
                    console.log('Dot selection cleared via Escape key');
                }
                // Also clear merge selection
                selectedPointsForMerge.forEach(circle => {
                    circle.set({ fill: '#FF0000', stroke: '#FFFFFF', strokeWidth: 2 });
                });
                selectedPointsForMerge = [];
                updateMergeButtonText();
            } else if (e.key === 'Enter' && !e.shiftKey && !e.ctrlKey && !e.altKey) {
                // Enter key to finish plot creation/editing (only if not in input field)
                if (document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'TEXTAREA') {
                    // Don't create plot if a plot is selected for deletion
                    if (selectedPlotForDelete) {
                        // Just deselect the plot, don't create new plot
                        clearPlotSelection();
                        return;
                    }
                    // Only create/modify plot if in create mode and have points
                    if (createMode) {
                        const totalPoints = selectedExistingCircles.length + newPlotPoints.length;
                        
                        // If editing existing plot (has selectedExistingCircles), modify it directly
                        // No minimum point requirement - user can add any number of points
                        if (selectedExistingCircles.length > 0 && newPlotPoints.length > 0) {
                            // Get unique plot IDs from selected circles
                            const selectedPlotIds = new Set(selectedExistingCircles.map(c => c.plotId).filter(id => id && id !== 'new_plot'));
                            
                            // If all selected circles belong to the same existing plot, modify that plot
                            if (selectedPlotIds.size === 1) {
                                const plotIdToModify = Array.from(selectedPlotIds)[0];
                                modifyExistingPlot(plotIdToModify, selectedExistingCircles, newPlotPoints);
                                return;
                            }
                        }
                        
                        // Creating a NEW plot (no selectedExistingCircles) - requires 3+ points
                        if (selectedExistingCircles.length === 0) {
                            if (newPlotPoints.length >= 3) {
                                createNewPlot();
                            } else if (newPlotPoints.length > 0) {
                                // Only show alert when creating NEW plot with insufficient points
                                alert('A new plot needs at least 3 points. Please add more points before finishing.');
                            }
                            // If no points, do nothing
                        }
                    }
                }
            } else if (e.key === 'Delete' || e.key === 'Backspace') {
                // Delete key to delete selected plot, points, or newly created points (LIFO)
                if (document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'TEXTAREA') {
                    // LIFO: If in create mode and there are newly created points, delete the last one (most recent)
                    if (createMode && newPlotPoints.length > 0) {
                        const lastPoint = newPlotPoints.pop(); // Remove last point (LIFO)
                        canvas.remove(lastPoint);
                        canvas.renderAll();
                        
                        // Update button text to show remaining points
                        updateCreateButtonText();
                        console.log('Deleted last created point. Remaining points:', newPlotPoints.length);
                        return;
                    }
                    
                    if (selectedPlotForDelete) {
                        showDeleteConfirmation(selectedPlotForDelete);
                    } else if (selectedDotsForMove.length > 0) {
                        // Delete selected points
                        selectedDotsForMove.forEach(circle => {
                            const plotId = circle.plotId;
                            if (plotId && plotPoints[plotId]) {
                                const index = plotPoints[plotId].indexOf(circle);
                                if (index > -1) {
                                    plotPoints[plotId].splice(index, 1);
                                    canvas.remove(circle);
                                    if (plotPoints[plotId].length < 3) {
                                        // Plot has less than 3 points, remove it
                                        const polygon = plotObjects.find(p => p.plotId === plotId);
                                        if (polygon) {
                                            canvas.remove(polygon);
                                            const plotIndex = plotObjects.indexOf(polygon);
                                            if (plotIndex > -1) plotObjects.splice(plotIndex, 1);
                                        }
                                        delete plotPoints[plotId];
                                    } else {
                                        updatePolygon(plotId);
                                    }
                                }
                            }
                        });
                        selectedDotsForMove = [];
                        updateMoveButtonCounter();
                        canvas.renderAll();
                    }
                }
            }
        });
        
        // Show help tooltip on first load (auto-hide after 8 seconds)
        setTimeout(function() {
            const helpTooltip = document.getElementById('help-tooltip');
            if (helpTooltip) {
                helpTooltip.style.display = 'block';
                // Auto-hide after 8 seconds
                setTimeout(function() {
                    helpTooltip.style.display = 'none';
                }, 8000);
            }
        }, 1500);
        
        // Override pan methods to prevent panning
        const originalPan = canvas.absolutePan;
        canvas.absolutePan = function() {
            if (!createMode) {
                return originalPan.apply(this, arguments);
            }
            return this;
        };

        // Parse plots data
        let plotsData;
        try {
            plotsData = JSON.parse('{{PLOTS_DATA}}');
        } catch (e) {
            console.error('Error parsing plots data:', e);
            plotsData = [];
        }
        
        const backgroundImageUrl = '{{BACKGROUND_IMAGE_URL}}';
        const mode = '{{MODE}}'; // "points" or "lines"
        
        // Store plot objects and their points
        const plotObjects = [];
        const plotPoints = {}; // plotId -> array of circle objects
        let mergeMode = false;
        let createMode = false;
        let deleteMode = false;
        let selectedPointsForMerge = [];
        let newPlotPoints = [];
        let selectedExistingCircles = []; // Track existing circles selected for new plot creation
        let selectedPlotForDelete = null;
        let pendingPlotData = null; // Store plot data before number assignment
        let selectedDotsForMove = []; // Track dots selected for pixel movement
        let moveDotsMode = false; // Track if we're in move dots selection mode
        
        // Canvas zoom functionality - zooms entire canvas (image, plots, dots)
        let canvasViewZoom = 1.0;
        const originalPolygonPoints = {}; // Store original polygon points

        // Function to load and display the image
        function loadBackgroundImage() {
            console.log('Loading background image from URL:', backgroundImageUrl ? backgroundImageUrl.substring(0, 50) + '...' : 'null');
            
            if (!backgroundImageUrl || backgroundImageUrl === 'null' || backgroundImageUrl === '') {
                console.error('Background image URL is empty or null');
                const loadingMsg = document.getElementById('loading-message');
                if (loadingMsg) {
                    loadingMsg.textContent = 'Error: No background image provided';
                    loadingMsg.style.color = '#ff0000';
                }
                // Still add plot elements even without background
                addPlotElements(1, 0, 0);
                return;
            }
            
            fabric.Image.fromURL(backgroundImageUrl, function(bgImg) {
                if (!bgImg) {
                    console.error('Failed to load background image');
                    // Still add plot elements even if image fails to load
                    addPlotElements(1, 0, 0);
                    return;
                }
                
                console.log('Background image loaded:', bgImg.width, 'x', bgImg.height);
                
                // Get actual canvas container dimensions
                const container = document.getElementById('canvas-container');
                const containerWidth = container.clientWidth || 1200;
                const containerHeight = container.clientHeight || 800;
                
                // Update canvas dimensions to match container exactly
                // This ensures pointer calculations are accurate
                canvas.setDimensions({
                    width: containerWidth,
                    height: containerHeight
                }, {
                    backstoreOnly: false  // Update both backstore and frontstore
                });
                
                // Ensure canvas element matches dimensions
                const canvasElement = canvas.getElement();
                if (canvasElement) {
                    canvasElement.width = containerWidth;
                    canvasElement.height = containerHeight;
                }
                
                // Recalculate offset to ensure pointer calculations respect zoom/pan
                canvas.calcOffset();
                
                // Calculate bounds of all plots to ensure they all fit
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                plotsData.forEach(plot => {
                    if (plot.points && plot.points.length >= 3) {
                        plot.points.forEach(point => {
                            minX = Math.min(minX, point.x);
                            minY = Math.min(minY, point.y);
                            maxX = Math.max(maxX, point.x);
                            maxY = Math.max(maxY, point.y);
                        });
                    }
                });
                
                // Calculate the actual bounds we need to display
                // Use the maximum of image dimensions and plot bounds
                const imageMaxX = bgImg.width;
                const imageMaxY = bgImg.height;
                const imageMinX = 0;
                const imageMinY = 0;
                
                // Get the overall bounds (image + plots) - ensure we include everything
                const overallMinX = Math.min(imageMinX, minX !== Infinity ? minX : imageMinX);
                const overallMinY = Math.min(imageMinY, minY !== Infinity ? minY : imageMinY);
                const overallMaxX = Math.max(imageMaxX, maxX !== -Infinity ? maxX : imageMaxX);
                const overallMaxY = Math.max(imageMaxY, maxY !== -Infinity ? maxY : imageMaxY);
                
                // Calculate dimensions needed
                const contentWidth = overallMaxX - overallMinX;
                const contentHeight = overallMaxY - overallMinY;
                
                // Add padding to ensure nothing is cut off at edges
                // Use more padding for better visibility
                const padding = 60;
                const availableWidth = containerWidth - (padding * 2);
                const availableHeight = containerHeight - (padding * 2);
                
                // Calculate scale to fit everything
                // Use 95% for lines mode, 85% for points mode to ensure all plots are clearly visible
                const scaleFactor = mode === 'lines' ? 0.95 : 0.85;
                const scaleX = (availableWidth * scaleFactor) / contentWidth;
                const scaleY = (availableHeight * scaleFactor) / contentHeight;
                const scale = Math.min(scaleX, scaleY);
                
                console.log('Scale calculation:', {
                    mode: mode,
                    scaleFactor: scaleFactor,
                    contentWidth: contentWidth,
                    contentHeight: contentHeight,
                    availableWidth: availableWidth,
                    availableHeight: availableHeight,
                    finalScale: scale
                });
                
                // Calculate the offset needed to center the content
                // This offset is relative to the overall bounds (starting from overallMinX, overallMinY)
                const scaledContentWidth = contentWidth * scale;
                const scaledContentHeight = contentHeight * scale;
                
                // Center the content in the available space
                // For proper centering, we need to account for the entire content bounds
                const baseOffsetX = (containerWidth - scaledContentWidth) / 2;
                const baseOffsetY = (containerHeight - scaledContentHeight) / 2;
                
                // For plots: offset from the overall minimum to center everything
                // Subtract the scaled minimum coordinates to shift content to center
                const offsetX = baseOffsetX - (overallMinX * scale);
                const offsetY = baseOffsetY - (overallMinY * scale);
                
                // For the background image: offset from (0,0) since image starts at origin
                // Use the same logic to ensure image and plots are aligned
                const imageOffsetX = baseOffsetX - (overallMinX * scale);
                const imageOffsetY = baseOffsetY - (overallMinY * scale);
                
                console.log('Image scale:', scale, 'Image offset:', imageOffsetX, imageOffsetY, 'Plot offset:', offsetX, offsetY);
                console.log('Content bounds - X:', overallMinX, 'to', overallMaxX, 'Y:', overallMinY, 'to', overallMaxY);
                
                // Add background as a REGULAR OBJECT (not backgroundImage) so it moves with everything
                // This ensures perfect synchronization during pan operations
                // CRITICAL: Background image scaling should NOT affect coordinate space
                // The coordinate space is independent of background image transformations
                // All coordinate calculations use stored scale/offset values from circles, not background image
                // CRITICAL: Background image is non-selectable and should not be re-scaled after initialization
                bgImg.set({
                    scaleX: scale,
                    scaleY: scale,
                    left: imageOffsetX,
                    top: imageOffsetY,
                    originX: 'left',
                    originY: 'top',
                    selectable: false,  // CRITICAL: Non-selectable
                    evented: false,     // CRITICAL: Non-interactive
                    isBackgroundImage: true,  // Custom flag to identify it
                    objectCaching: false,     // Disable caching for accurate coordinate handling
                    noScaleCache: true,      // Disable scale cache
                    statefullCache: false,   // Disable stateful cache
                    lockMovementX: true,      // CRITICAL: Lock movement
                    lockMovementY: true,     // CRITICAL: Lock movement
                    lockRotation: true,      // CRITICAL: Lock rotation
                    lockScalingX: true,      // CRITICAL: Lock scaling (don't re-scale after init)
                    lockScalingY: true       // CRITICAL: Lock scaling (don't re-scale after init)
                });
                
                // CRITICAL: Store original values for coordinate calculations
                // These original values are used as fallback when no circles exist
                // This ensures background image transformations (zoom/pan) don't affect coordinate space
                bgImg.originalScaleX = scale;
                bgImg.originalScaleY = scale;
                bgImg.originalLeft = imageOffsetX;
                bgImg.originalTop = imageOffsetY;
                
                // Add as regular object
                canvas.add(bgImg);
                canvas.sendToBack(bgImg);
                
                // Also set as canvas.backgroundImage reference for compatibility
                window.canvasBgImg = bgImg;
                
                // Set initial visibility to true (background shown by default)
                bgImg.set('visible', true);
                
                // Listen for background toggle messages from parent
                window.addEventListener('message', function(event) {
                    // Accept messages from same origin or from Streamlit parent
                    if (event.data && event.data.type === 'toggle_background') {
                        const showBackground = event.data.show;
                        if (window.canvasBgImg) {
                            window.canvasBgImg.set('visible', showBackground);
                            canvas.renderAll();
                            console.log('Background visibility toggled:', showBackground);
                        }
                    }
                });
                
                // Expose function to toggle background (for direct access if needed)
                window.toggleBackground = function(show) {
                    if (window.canvasBgImg) {
                        window.canvasBgImg.set('visible', show !== false);
                        canvas.renderAll();
                    }
                };

                // Add plot polygons/points after background loads with the overall offset
                addPlotElements(scale, offsetX, offsetY);
                
                // Ensure background image stays at the very back after adding all elements
                // Also ensure plots are visible above the background
                setTimeout(() => {
                    // Keep background at the very back
                    if (window.canvasBgImg) {
                        canvas.sendToBack(window.canvasBgImg);
                    }
                    
                    // Bring all plot elements (circles, polygons, text) to front
                    // Order: background < polygons < circles < text
                    canvas.getObjects().forEach(obj => {
                        if (obj.isBackgroundImage) {
                            canvas.sendToBack(obj);
                        } else if (obj.type === 'polygon' && obj.plotId) {
                            canvas.sendToBack(obj);
                            canvas.bringForward(obj); // One level above background
                        } else if (obj.type === 'circle' && obj.plotId) {
                            canvas.bringToFront(obj);
                        } else if (obj.type === 'text' && obj.plotId) {
                            canvas.bringToFront(obj);
                        }
                    });
                    canvas.renderAll();
                }, 100);
                
                // Hide loading message
                const loadingMsg = document.getElementById('loading-message');
                if (loadingMsg) {
                    loadingMsg.style.display = 'none';
                }
            }, {
                crossOrigin: 'anonymous'
            });
        }
        
        // Start loading the background image
        loadBackgroundImage();

        function addPlotElements(scale, offsetX, offsetY) {
            console.log('Adding plot elements. Scale:', scale, 'Offset:', offsetX, offsetY, 'Plots:', plotsData.length);
            
            if (!plotsData || plotsData.length === 0) {
                console.warn('No plots data available');
                return;
            }
            
            plotsData.forEach((plot, index) => {
                if (!plot.points || plot.points.length < 3) {
                    console.warn('Plot', plot.id, 'has insufficient points:', plot.points);
                    return;
                }

                // CRITICAL: Verify we're loading all points
                if (plot.points.length < 3) {
                    console.error('‚ùå ERROR: Plot', plot.id, 'has less than 3 points! This should not happen.');
                }

                // Scale and offset points to match background image
                const points = plot.points.map(point => ({
                    x: (point.x * scale) + offsetX,
                    y: (point.y * scale) + offsetY
                }));

                // Store original pixel coordinates (before scaling)
                const originalPoints = plot.points.map(p => ({x: p.x, y: p.y}));
                
                console.log('Created', points.length, 'scaled points for plot', plot.id);

                // Create circles (red dots) for each corner point
                const circles = [];
                points.forEach((point, pointIndex) => {
                    const circle = new fabric.Circle({
                        left: point.x,
                        top: point.y,
                        radius: 4,
                        fill: '#FF0000', // Red
                        stroke: '#FFFFFF',
                        strokeWidth: 2,
                        originX: 'center',
                        originY: 'center',
                        selectable: true,
                        hasControls: false,
                        hasBorders: true,
                        borderColor: '#0066CC',
                        cornerColor: '#0066CC',
                        cornerSize: 8,
                        plotId: plot.id,
                        pointIndex: pointIndex,
                        originalX: originalPoints[pointIndex].x,
                        originalY: originalPoints[pointIndex].y,
                        scale: scale,
                        offsetX: offsetX,
                        offsetY: offsetY,
                        objectCaching: false,     // Disable caching for accurate coordinate handling
                        noScaleCache: true,      // Disable scale cache
                        statefullCache: false    // Disable stateful cache
                    });

                    // Track if circle was moved (to distinguish click from drag)
                    let circleMoved = false;
                    let circleMouseDownTime = 0;
                    
                    // Make circle easily clickable for selection
                    circle.set({
                        evented: true,
                        selectable: true,  // Allow selection for dragging
                        hoverCursor: 'pointer',
                        perPixelTargetFind: true  // Better click detection
                    });
                    
                    // Make circles draggable - lines follow the dots
                    circle.on('moving', function(e) {
                        circleMoved = true; // Track that circle was moved
                        
                        // Update original coordinates when circle is moved
                        // Use the scale and offset stored when the circle was created
                        // This ensures consistency even if background image position changes
                        const storedScale = this.scale || 1;
                        const storedOffsetX = this.offsetX || 0;
                        const storedOffsetY = this.offsetY || 0;
                        
                        // Calculate original coordinates using the stored scale/offset
                        // This ensures coordinates are always relative to the original image
                        this.originalX = Math.round((this.left - storedOffsetX) / storedScale);
                        this.originalY = Math.round((this.top - storedOffsetY) / storedScale);
                        
                        // CRITICAL: Update selection box coordinates to prevent offset
                        // Must call setCoords() to ensure selection boxes align correctly
                        this.setCoords();
                        
                        // CRITICAL: Update polygon in real-time if in lines mode
                        // updatePolygon uses absolute left/top of circles, ensuring points stay attached
                        if (mode === 'lines') {
                            updatePolygon(plot.id);
                        }
                        canvas.renderAll();
                    });
                    
                    // Add click handler for merge mode, create mode, and plot selection
                    circle.on('mousedown', function(e) {
                        circleMoved = false;
                        circleMouseDownTime = Date.now();
                        
                        // Handle Ctrl+Click for multi-dot selection (for pixel move and merge)
                        if (e.e.ctrlKey || e.e.metaKey) {
                            e.e.stopPropagation();
                            e.e.stopImmediatePropagation();
                            
                            // Add to move selection
                            const isAlreadySelectedMove = selectedDotsForMove.includes(this);
                            
                            if (isAlreadySelectedMove) {
                                // Deselect from move
                                const index = selectedDotsForMove.indexOf(this);
                                selectedDotsForMove.splice(index, 1);
                            } else {
                                // Select for move
                                selectedDotsForMove.push(this);
                            }
                            
                            // Also handle merge selection (max 2 points)
                            const isAlreadySelectedMerge = selectedPointsForMerge.includes(this);
                            
                            if (isAlreadySelectedMerge) {
                                // Deselect from merge
                                const index = selectedPointsForMerge.indexOf(this);
                                selectedPointsForMerge.splice(index, 1);
                                this.set({ fill: '#FF0000', stroke: '#FFFFFF', strokeWidth: 2 });
                            } else {
                                // Select for merge (max 2 points)
                                if (selectedPointsForMerge.length < 2) {
                                    selectedPointsForMerge.push(this);
                                    this.set({ fill: '#00FF00', stroke: '#000000', strokeWidth: 3 });
                                } else {
                                    // Already have 2 selected, replace first
                                    const firstPoint = selectedPointsForMerge[0];
                                    firstPoint.set({ fill: '#FF0000', stroke: '#FFFFFF', strokeWidth: 2 });
                                    selectedPointsForMerge.shift();
                                    selectedPointsForMerge.push(this);
                                    this.set({ fill: '#00FF00', stroke: '#000000', strokeWidth: 3 });
                                }
                            }
                            
                            // Update visual for move selection
                            if (isAlreadySelectedMove) {
                                this.set({ stroke: '#FFFFFF', strokeWidth: 2 });
                            } else {
                                this.set({ stroke: '#4CAF50', strokeWidth: 4 }); // Green highlight for move
                            }
                            
                            this.setCoords();
                            canvas.renderAll();
                            updateMoveButtonCounter();
                            updateMergeButtonText();
                            return false;
                        }
                        
                        if (createMode) {
                            // In create mode, handle circle selection for new plot
                            e.e.stopPropagation();
                            e.e.stopImmediatePropagation();
                            
                            // Check if already selected
                            const isAlreadySelected = selectedExistingCircles.includes(this);
                            
                            if (isAlreadySelected) {
                                // Deselect
                                const index = selectedExistingCircles.indexOf(this);
                                selectedExistingCircles.splice(index, 1);
                                this.set({
                                    fill: '#FF0000',
                                    stroke: '#FFFFFF',
                                    strokeWidth: 2
                                });
                                this.setCoords();
                                console.log('Deselected existing circle. Selected:', selectedExistingCircles.length);
                            } else {
                                // Select (max 4)
                                if (selectedExistingCircles.length < 4) {
                                    selectedExistingCircles.push(this);
                                    this.set({
                                        fill: '#00FF00', // Green for selected
                                        stroke: '#FFFFFF',
                                        strokeWidth: 3
                                    });
                                    this.setCoords();
                                    console.log('Selected existing circle. Selected:', selectedExistingCircles.length, '/ 4');
                                } else {
                                    alert('You can select up to 4 existing dots. Click on a selected dot to deselect it, or create additional points.');
                                    return false;
                                }
                            }
                            
                            updateCreateButtonText();
                            canvas.renderAll();
                            return false;
                        } else if (!createMode && !mergeMode) {
                            // Allow normal Fabric.js selection and dragging for dots
                            // Don't stop propagation - let Fabric.js handle selection and dragging
                            // Plot selection will be handled in mouseup if it was just a click (not drag)
                        }
                    });
                    
                    // Handle mouseup for plot selection (only if not dragged)
                    circle.on('mouseup', function(e) {
                        if (!createMode && !circleMoved) {
                            // Only select if it was a click (not a drag)
                            const clickDuration = Date.now() - circleMouseDownTime;
                            if (clickDuration < 300) { // Quick click, not a drag
                                e.e.stopPropagation();
                                e.e.stopImmediatePropagation();
                                console.log('Circle clicked (not dragged), selecting plot:', this.plotId);
                                if (this.plotId) {
                                    selectPlotForDelete(this.plotId);
                                } else {
                                    console.error('Circle has no plotId!', this);
                                }
                                return false;
                            }
                        }
                        circleMoved = false;
                    });
                    

                    circles.push(circle);
                    canvas.add(circle);
                });

                plotPoints[plot.id] = circles;

                // If mode is "lines", also draw the polygon lines
                if (mode === 'lines') {
                    // Calculate bounding box to set polygon position
                    const minX = Math.min(...points.map(p => p.x));
                    const minY = Math.min(...points.map(p => p.y));
                    
                    // Convert points to relative coordinates (relative to minX, minY)
                    // This ensures the polygon stays anchored at its position
                    const relativePoints = points.map(point => ({
                        x: point.x - minX,
                        y: point.y - minY
                    }));
                    
                    const polygon = new fabric.Polygon(relativePoints, {
                        left: minX,
                        top: minY,
                        fill: 'rgba(255, 0, 0, 0.01)', // Very light fill to make it more clickable
                        stroke: '#FF0000', // Red lines
                        strokeWidth: 2,
                        opacity: 0.7,
                        selectable: false, // Not selectable - only dots are draggable
                        evented: true, // Make sure it can receive events
                        hoverCursor: 'pointer', // Show pointer cursor on hover
                        plotId: plot.id,
                        plotNumber: plot.plot_number,
                        hasControls: false,
                        hasBorders: false,
                        objectCaching: false,  // Disable caching for accurate coordinate handling
                        noScaleCache: true,    // Disable scale cache
                        statefullCache: false, // Disable stateful cache
                        perPixelTargetFind: true // Better click detection
                    });
                    
                    // Store original position to keep polygon anchored when points move
                    polygon.originalLeft = minX;
                    polygon.originalTop = minY;
                    
                    // Add click handler for plot selection and point creation
                    polygon.on('mousedown', function(e) {
                        // In create mode, allow clicking on polygon to add points on the line
                        if (createMode) {
                            e.e.stopPropagation();
                            e.e.stopImmediatePropagation();
                            
                            // Convert mouse coordinates to world coordinates
                            const worldPoint = mouseToWorldCoordinates(canvas, e.e);
                            
                            // Find closest point on polygon line segment
                            const closest = findClosestPointOnPolygon(worldPoint, polygon);
                            
                            if (closest && closest.point) {
                                // Create point at projected location on the line
                                // Use handleCreatePlotClick logic but with projected coordinates
                                const projectedPoint = closest.point;
                                
                                // Get scale/offset for coordinate conversion
                                const allExistingCircles = Object.values(plotPoints).flat();
                                let scale = 1;
                                let offsetX = 0;
                                let offsetY = 0;
                                
                                if (allExistingCircles.length > 0) {
                                    scale = allExistingCircles[0].scale || 1;
                                    offsetX = allExistingCircles[0].offsetX || 0;
                                    offsetY = allExistingCircles[0].offsetY || 0;
                                } else {
                                    const bgImg = window.canvasBgImg || canvas.backgroundImage;
                                    if (bgImg) {
                                        scale = bgImg.originalScaleX || bgImg.scaleX || 1;
                                        offsetX = bgImg.originalLeft || bgImg.left || 0;
                                        offsetY = bgImg.originalTop || bgImg.top || 0;
                                    }
                                }
                                
                                // Calculate original coordinates
                                const originalX = Math.round((projectedPoint.x - offsetX) / scale);
                                const originalY = Math.round((projectedPoint.y - offsetY) / scale);
                                
                                // Check if too close to existing points from other plots
                                const minDistance = 15;
                                let tooClose = false;
                                
                                Object.values(plotPoints).flat().forEach(existingCircle => {
                                    if (existingCircle.plotId !== 'new_plot' && !selectedExistingCircles.includes(existingCircle)) {
                                        const dx = projectedPoint.x - existingCircle.left;
                                        const dy = projectedPoint.y - existingCircle.top;
                                        const distance = Math.sqrt(dx * dx + dy * dy);
                                        if (distance < minDistance) {
                                            tooClose = true;
                                        }
                                    }
                                });
                                
                                if (!tooClose) {
                                    // Create point at projected location
                                    const circle = new fabric.Circle({
                                        left: projectedPoint.x,
                                        top: projectedPoint.y,
                                        radius: 4,
                                        fill: '#0000FF',
                                        stroke: '#FFFFFF',
                                        strokeWidth: 2,
                                        originX: 'center',
                                        originY: 'center',
                                        selectable: true,
                                        hasControls: false,
                                        hasBorders: true,
                                        borderColor: '#0066CC',
                                        cornerColor: '#0066CC',
                                        cornerSize: 8,
                                        plotId: 'new_plot',
                                        pointIndex: newPlotPoints.length,
                                        scale: scale,
                                        offsetX: offsetX,
                                        offsetY: offsetY,
                                        originalX: originalX,
                                        originalY: originalY,
                                        evented: true,
                                        hoverCursor: 'move',
                                        moveCursor: 'move',
                                        objectCaching: false,
                                        noScaleCache: true,
                                        statefullCache: false
                                    });
                                    
                                    circle.on('moving', function(e) {
                                        const storedScale = this.scale || 1;
                                        const storedOffsetX = this.offsetX || 0;
                                        const storedOffsetY = this.offsetY || 0;
                                        
                                        this.originalX = Math.round((this.left - storedOffsetX) / storedScale);
                                        this.originalY = Math.round((this.top - storedOffsetY) / storedScale);
                                        
                                        this.setCoords();
                                        canvas.renderAll();
                                    });
                                    
                                    newPlotPoints.push(circle);
                                    canvas.add(circle);
                                    canvas.bringToFront(circle);
                                    canvas.renderAll();
                                    
                                    updateCreateButtonText();
                                }
                            }
                            
                            return false;
                        }
                        
                        // In delete mode, select plot for deletion
                        if (!createMode && !mergeMode) {
                            e.e.stopPropagation();
                            e.e.stopImmediatePropagation();
                            console.log('Polygon clicked, selecting plot:', plot.id);
                            selectPlotForDelete(plot.id);
                            return false;
                        }
                    });
                    
                    // Also handle mouseup for better click detection
                    polygon.on('mouseup', function(e) {
                        if (!createMode && !mergeMode) {
                            e.e.stopPropagation();
                            e.e.stopImmediatePropagation();
                            console.log('Polygon mouseup, selecting plot:', plot.id);
                            selectPlotForDelete(plot.id);
                            return false;
                        }
                    });

                    // Update polygon when points move
                    circles.forEach((circle, idx) => {
                        circle.on('modified', function() {
                            updatePolygon(plot.id);
                        });
                        circle.on('moving', function(e) {
                            // Update original coordinates when circle is moved
                            const storedScale = this.scale || 1;
                            const storedOffsetX = this.offsetX || 0;
                            const storedOffsetY = this.offsetY || 0;
                            
                            this.originalX = Math.max(0, Math.round((this.left - storedOffsetX) / storedScale));
                            this.originalY = Math.max(0, Math.round((this.top - storedOffsetY) / storedScale));
                            
                            // CRITICAL: Update selection box coordinates to prevent offset
                            // Must call setCoords() to ensure selection boxes align correctly
                            this.setCoords();
                            
                            // CRITICAL: Update polygon in real-time
                            // updatePolygon uses absolute left/top of circles, ensuring points stay attached
                            updatePolygon(plot.id);
                        });
                    });

                    plotObjects.push(polygon);
                    canvas.add(polygon);
                    
                    // Store original polygon points for zoom functionality
                    originalPolygonPoints[plot.id] = points.map(p => ({x: p.x, y: p.y}));
                    
                    // Ensure proper z-order: background < polygon < circles < text
                    // CRITICAL: Ensure background is at the very back
                    if (canvas.backgroundImage) {
                        canvas.sendToBack(canvas.backgroundImage);
                    }
                    // Bring polygon to front (above background, will be below circles/text later)
                    canvas.bringToFront(polygon);
                }

                // Add plot number label in center
                const centerX = points.reduce((sum, p) => sum + p.x, 0) / points.length;
                const centerY = points.reduce((sum, p) => sum + p.y, 0) / points.length;
                
                const text = new fabric.Text(String(plot.plot_number || plot.id), {
                    left: centerX,
                    top: centerY,
                    fontSize: 14,
                    fill: '#000000',
                    originX: 'center',
                    originY: 'center',
                    selectable: false,
                    evented: false,
                    plotId: plot.id,
                    objectCaching: false,  // Disable caching for accurate coordinate handling
                    noScaleCache: true,   // Disable scale cache
                    statefullCache: false // Disable stateful cache
                });
                
                // Store original position for zoom functionality
                text.originalLeft = centerX;
                text.originalTop = centerY;
                canvas.add(text);
                
                // Bring circles and text to front
                circles.forEach(circle => canvas.bringToFront(circle));
                canvas.bringToFront(text);
            });

            canvas.renderAll();
            
            // Hide loading message after plots are added
            const loadingMsg = document.getElementById('loading-message');
            if (loadingMsg) {
                loadingMsg.style.display = 'none';
            }
        }

        // ============================================
        // 2D Geometry Helper Functions
        // ============================================
        
        /**
         * Convert mouse/screen coordinates to world coordinates by inverting viewportTransform.
         * This ensures geometry calculations are done in world space, independent of zoom/pan.
         */
        function mouseToWorldCoordinates(canvas, mouseEvent) {
            const pointer = canvas.getPointer(mouseEvent, true);
            const vpt = canvas.viewportTransform;
            
            if (!vpt) {
                return { x: pointer.x, y: pointer.y };
            }
            
            // Invert the viewport transform matrix to get world coordinates
            // viewportTransform is a 3x3 matrix stored as [a, b, c, d, e, f, 0, 0, 1]
            // where [a, b, c, d] is the 2x2 transform and [e, f] is the translation
            const a = vpt[0], b = vpt[1], c = vpt[2], d = vpt[3], e = vpt[4], f = vpt[5];
            
            // Calculate determinant
            const det = a * d - b * c;
            
            if (Math.abs(det) < 1e-10) {
                // Singular matrix, fallback to pointer coordinates
                return { x: pointer.x, y: pointer.y };
            }
            
            // Inverse transform: [x', y'] = inv([a, b; c, d]) * ([x, y] - [e, f])
            const invDet = 1 / det;
            const invA = d * invDet;
            const invB = -b * invDet;
            const invC = -c * invDet;
            const invD = a * invDet;
            
            const tx = pointer.x - e;
            const ty = pointer.y - f;
            
            return {
                x: invA * tx + invC * ty,
                y: invB * tx + invD * ty
            };
        }
        
        /**
         * Get line segment endpoints in world coordinates from a polygon.
         * Returns an array of segments, each with {start: {x, y}, end: {x, y}}.
         * 
         * CRITICAL: Polygon points are stored relative to polygon.left/top.
         * We need to convert them to absolute world coordinates.
         * In Fabric.js, object.left/top are in canvas/world coordinates (not affected by viewportTransform).
         */
        function getPolygonSegmentsInWorldSpace(polygon) {
            if (!polygon || !polygon.points || polygon.points.length < 2) {
                return [];
            }
            
            // Get relative points and polygon position
            // polygon.points are relative to polygon.left/top
            const relativePoints = polygon.points;
            const polyLeft = polygon.left || 0;
            const polyTop = polygon.top || 0;
            
            // Convert relative points to absolute world coordinates
            // These are already in world space since polygon.left/top are in world coordinates
            const absolutePoints = relativePoints.map(relPoint => ({
                x: relPoint.x + polyLeft,
                y: relPoint.y + polyTop
            }));
            
            // Create segments from consecutive points (closed polygon)
            const segments = [];
            for (let i = 0; i < absolutePoints.length; i++) {
                const start = absolutePoints[i];
                const end = absolutePoints[(i + 1) % absolutePoints.length]; // Wrap around for closed polygon
                segments.push({ start, end });
            }
            
            return segments;
        }
        
        /**
         * Project a point onto a line segment using vector projection.
         * Returns the projected point clamped to the segment endpoints.
         */
        function projectPointOntoLineSegment(point, segment) {
            const { start, end } = segment;
            
            // Vector from start to end
            const dx = end.x - start.x;
            const dy = end.y - start.y;
            const segmentLengthSq = dx * dx + dy * dy;
            
            // If segment has zero length, return start point
            if (segmentLengthSq < 1e-10) {
                return { x: start.x, y: start.y };
            }
            
            // Vector from start to point
            const px = point.x - start.x;
            const py = point.y - start.y;
            
            // Project point onto line: t = dot(px, segment) / ||segment||^2
            const t = (px * dx + py * dy) / segmentLengthSq;
            
            // Clamp t to [0, 1] to ensure point lies on segment
            const clampedT = Math.max(0, Math.min(1, t));
            
            // Calculate projected point
            return {
                x: start.x + clampedT * dx,
                y: start.y + clampedT * dy
            };
        }
        
        /**
         * Find the closest point on a polygon to a given world-space point.
         * Returns the projected point and the segment index.
         */
        function findClosestPointOnPolygon(worldPoint, polygon) {
            const segments = getPolygonSegmentsInWorldSpace(polygon);
            
            if (segments.length === 0) {
                return null;
            }
            
            let closestPoint = null;
            let minDistance = Infinity;
            let closestSegmentIndex = -1;
            
            segments.forEach((segment, index) => {
                const projected = projectPointOntoLineSegment(worldPoint, segment);
                const dx = projected.x - worldPoint.x;
                const dy = projected.y - worldPoint.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < minDistance) {
                    minDistance = distance;
                    closestPoint = projected;
                    closestSegmentIndex = index;
                }
            });
            
            return {
                point: closestPoint,
                segmentIndex: closestSegmentIndex,
                distance: minDistance
            };
        }

        function updatePolygon(plotId) {
            const circles = plotPoints[plotId];
            if (!circles) return;

            const polygon = plotObjects.find(p => p.plotId === plotId);
            if (!polygon) return;

            // CRITICAL: Use absolute left/top of circles for polygon points
            // Do NOT apply zoom or scaling math manually - use actual circle positions
            const newPoints = circles.map(circle => {
                // Get absolute canvas coordinates directly from circle objects
                // These are the actual canvas positions, respecting all transformations
                return {
                    x: circle.left,  // CRITICAL: Use absolute left directly
                    y: circle.top    // CRITICAL: Use absolute top directly
                };
            });
            
            // Calculate bounding box to set polygon position
            const minX = Math.min(...newPoints.map(p => p.x));
            const minY = Math.min(...newPoints.map(p => p.y));
            
            // Convert to relative coordinates (relative to bounding box minimum)
            const relativePoints = newPoints.map(point => ({
                x: point.x - minX,
                y: point.y - minY
            }));
            
            // Store original position if not set (for anchoring)
            if (polygon.originalLeft === undefined || polygon.originalTop === undefined) {
                polygon.originalLeft = minX;
                polygon.originalTop = minY;
            }
            
            // CRITICAL: Update polygon with relative points and position
            // Position comes from circles' absolute left/top, not manual calculations
            polygon.set({
                points: relativePoints,
                left: minX,  // From circles' absolute positions
                top: minY,   // From circles' absolute positions
                visible: true,
                opacity: 0.7
            });
            
            // Update original position to track current position
            polygon.originalLeft = minX;
            polygon.originalTop = minY;
            
            // CRITICAL: Recalculate coordinates to ensure selection boxes align correctly
            polygon.setCoords();
            polygon.dirty = true;
            
            // CRITICAL: Update all circle coordinates to ensure selection boxes align correctly
            circles.forEach(circle => {
                circle.setCoords();
                canvas.bringToFront(circle);
            });
            
            // Ensure proper layering is maintained
            if (canvas.backgroundImage) {
                canvas.backgroundImage.moveTo(0);
            }
            
            canvas.renderAll();
        }

        function saveChanges() {
            // Collect updated coordinates - include all plots (existing, new, and handle deletions)
            const updatedPlots = [];
            
            // Get scale and offset from circles (stored when they were created)
            // This ensures we use the same transformation that was used to position circles
            let bgScale = 1;
            let bgOffsetX = 0;
            let bgOffsetY = 0;
            
            const allCircles = Object.values(plotPoints).flat();
            if (allCircles.length > 0) {
                // Use the scale/offset stored in circles (consistent across all circles)
                bgScale = allCircles[0].scale || 1;
                bgOffsetX = allCircles[0].offsetX || 0;
                bgOffsetY = allCircles[0].offsetY || 0;
            } else {
                // Fallback to background image if no circles exist
                const bgImg = canvas.backgroundImage;
                if (bgImg) {
                    bgScale = bgImg.scaleX || 1;
                    bgOffsetX = bgImg.left || 0;
                    bgOffsetY = bgImg.top || 0;
                }
            }
            
            // Process all plots in plotsData (existing plots, newly created ones, and modified ones)
            console.log('=== SAVE CHANGES ===');
            console.log('Total plots in plotsData:', plotsData.length);
            console.log('Plots in plotsData:', plotsData.map(p => ({ id: p.id, plot_number: p.plot_number, points_count: p.points ? p.points.length : 0 })));
            console.log('Plots in plotPoints:', Object.keys(plotPoints));
            
            plotsData.forEach(plot => {
                const circles = plotPoints[plot.id];
                if (!circles || circles.length === 0) {
                    // Plot was deleted or has no points - skip it
                    console.warn('‚ö†Ô∏è Plot', plot.id, 'has no circles in plotPoints, skipping');
                    return;
                }

                console.log('‚úì Processing plot:', plot.id, 'with', circles.length, 'circles');
                
                // CRITICAL: Verify we have all circles
                if (circles.length !== plot.points?.length) {
                    console.warn('‚ö†Ô∏è MISMATCH: plotPoints has', circles.length, 'circles but plotsData has', plot.points?.length, 'points for plot', plot.id);
                    console.warn('This means some points were lost! Check the save/load process.');
                }

                // Convert canvas coordinates back to original pixel coordinates
                // Always use stored originalX/originalY which are updated during movement
                // These represent the true original image coordinates
                const updatedPoints = circles.map((circle, idx) => {
                    let originalX, originalY;
                    
                    // Get scale/offset from circle if available, otherwise use global
                    // CRITICAL: Use circle's own scale/offset to preserve its position
                    const circleScale = circle.scale || bgScale;
                    const circleOffsetX = circle.offsetX !== undefined ? circle.offsetX : bgOffsetX;
                    const circleOffsetY = circle.offsetY !== undefined ? circle.offsetY : bgOffsetY;
                    
                    // Always use stored original coordinates if available
                    // These are updated in real-time when circles are moved
                    if (circle.originalX !== undefined && circle.originalY !== undefined) {
                        originalX = circle.originalX;
                        originalY = circle.originalY;
                    } else {
                        // Fallback: calculate from current canvas position using circle's own scale/offset
                        // This preserves the circle's position correctly
                        let canvasX = circle.left;
                        let canvasY = circle.top;
                        originalX = Math.round((canvasX - circleOffsetX) / circleScale);
                        originalY = Math.round((canvasY - circleOffsetY) / circleScale);
                        
                        // Store for future use
                        circle.originalX = originalX;
                        circle.originalY = originalY;
                        console.log('Calculated original coords for circle', idx, 'in plot', plot.id, ':', originalX, originalY, 'using scale:', circleScale, 'offset:', circleOffsetX, circleOffsetY);
                    }
                    
                    return {
                        x: Math.max(0, originalX), // Ensure non-negative
                        y: Math.max(0, originalY)
                    };
                });

                // CRITICAL: Verify we're saving all points
                if (updatedPoints.length !== circles.length) {
                    console.error('‚ùå ERROR: Mismatch! We have', circles.length, 'circles but only', updatedPoints.length, 'points to save!');
                }
                
                updatedPlots.push({
                    id: plot.id,
                    plot_number: plot.plot_number,
                    points: updatedPoints
                });
            });
            
            console.log('Total plots to save:', updatedPlots.length);

            // Store in localStorage with a unique key
            const storageKey = 'editable_plot_updates_' + Date.now();
            try {
                localStorage.setItem('editable_plot_updates', JSON.stringify({
                    type: 'plot_coordinates_updated',
                    plots: updatedPlots,
                    timestamp: Date.now(),
                    storageKey: storageKey
                }));
                // Also store with the key for retrieval
                localStorage.setItem(storageKey, JSON.stringify(updatedPlots));
            } catch (e) {
                console.error('Failed to save to localStorage:', e);
            }
            
            // Also try to communicate with parent window
            try {
                if (window.parent) {
                    window.parent.postMessage({
                        type: 'plot_coordinates_updated',
                        plots: updatedPlots,
                        timestamp: Date.now()
                    }, '*');
                }
            } catch (e) {
                console.error('Failed to post message:', e);
            }
            
            // Show success message
            const saveBtn = document.getElementById('save-btn');
            if (saveBtn) {
                const originalText = saveBtn.textContent;
                saveBtn.textContent = '‚úì Saved!';
                saveBtn.style.backgroundColor = '#4CAF50';
                setTimeout(() => {
                    saveBtn.textContent = originalText;
                    saveBtn.style.backgroundColor = '#0066CC';
                }, 2000);
            }
            
            // Also store in a data attribute on body for easier access
            try {
                document.body.setAttribute('data-saved-coords', JSON.stringify(updatedPlots));
            } catch (e) {
                console.error('Failed to set data attribute:', e);
            }
            
            // Show coordinates in a copy-friendly text area
            showCopyArea(updatedPlots);
            
            function showCopyArea(data) {
                // Create a prominent text area with the JSON for easy copying
                let copyArea = document.getElementById('coords-copy-area');
                if (!copyArea) {
                    copyArea = document.createElement('textarea');
                    copyArea.id = 'coords-copy-area';
                    copyArea.style.position = 'fixed';
                    copyArea.style.top = '10px';
                    copyArea.style.left = '10px';
                    copyArea.style.width = '400px';
                    copyArea.style.height = '150px';
                    copyArea.style.zIndex = '10000';
                    copyArea.style.backgroundColor = '#ffffcc';
                    copyArea.style.border = '3px solid #ff6b00';
                    copyArea.style.padding = '10px';
                    copyArea.style.fontSize = '11px';
                    copyArea.style.fontFamily = 'monospace';
                    copyArea.style.borderRadius = '8px';
                    copyArea.style.boxShadow = '0 4px 12px rgba(0,0,0,0.3)';
                    copyArea.readOnly = true;
                    
                    // Add title/header
                    const header = document.createElement('div');
                    header.style.position = 'fixed';
                    header.style.top = '10px';
                    header.style.left = '10px';
                    header.style.width = '400px';
                    header.style.backgroundColor = '#ff6b00';
                    header.style.color = 'white';
                    header.style.padding = '8px 10px';
                    header.style.fontWeight = 'bold';
                    header.style.fontSize = '12px';
                    header.style.zIndex = '10001';
                    header.style.borderRadius = '8px 8px 0 0';
                    header.innerHTML = 'üìã Copy these coordinates and paste below ‚Üì';
                    header.id = 'coords-header';
                    document.body.appendChild(header);
                    
                    // Adjust textarea to be below header
                    copyArea.style.top = '42px';
                    copyArea.style.borderRadius = '0 0 8px 8px';
                    
                    // Add close button
                    const closeBtn = document.createElement('button');
                    closeBtn.innerHTML = '‚úï';
                    closeBtn.style.position = 'absolute';
                    closeBtn.style.right = '5px';
                    closeBtn.style.top = '5px';
                    closeBtn.style.background = 'rgba(255,255,255,0.3)';
                    closeBtn.style.border = 'none';
                    closeBtn.style.color = 'white';
                    closeBtn.style.width = '24px';
                    closeBtn.style.height = '24px';
                    closeBtn.style.borderRadius = '4px';
                    closeBtn.style.cursor = 'pointer';
                    closeBtn.style.fontSize = '16px';
                    closeBtn.style.fontWeight = 'bold';
                    closeBtn.onclick = function() {
                        copyArea.style.display = 'none';
                        header.style.display = 'none';
                    };
                    header.appendChild(closeBtn);
                    
                    document.body.appendChild(copyArea);
                }
                
                const jsonData = JSON.stringify({plots: data}, null, 2);
                
                // Debug: Log what plots are being saved
                console.log('üìä Saving', data.length, 'plots to JSON');
                console.log('üìä Plot IDs:', data.map(p => p.id || p.plot_number || 'unknown'));
                const newPlots = data.filter(p => {
                    const plotNum = p.plot_number || (p.id ? parseInt(p.id.replace(/[^0-9]/g, '')) : null);
                    return plotNum && plotNum > 80; // Assuming plots above 80 are "new"
                });
                if (newPlots.length > 0) {
                    console.log('üÜï New plots detected:', newPlots.map(p => p.id || p.plot_number));
                }
                
                copyArea.value = jsonData;
                // Hide the yellow box - user doesn't need to see it
                copyArea.style.display = 'none';
                
                const header = document.getElementById('coords-header');
                if (header) {
                    // Hide the header too
                    header.style.display = 'none';
                }
                
                // Select all text for easy copying
                copyArea.select();
                copyArea.setSelectionRange(0, copyArea.value.length);
                
                // Try to copy to clipboard automatically (silently, box is hidden)
                try {
                    document.execCommand('copy');
                    console.log('‚úÖ Coordinates copied to clipboard automatically (hidden)');
                } catch (err) {
                    console.log('Auto-copy failed:', err);
                }
                
                // AUTO-FILL: Automatically populate the Streamlit textarea below
                // This eliminates the need for manual copy-paste
                try {
                    // The textarea is in the parent Streamlit page (not in this iframe)
                    // We need to access it via window.parent
                    if (window.parent && window.parent !== window) {
                        // Try multiple times with increasing delays to catch the textarea
                        // Streamlit might render it asynchronously
                        let attempts = 0;
                        const maxAttempts = 5;
                        
                        function tryAutoFill() {
                            attempts++;
                            console.log('üîÑ Attempt', attempts, 'to find and fill textarea...');
                            try {
                                // Find the Streamlit textarea by its data-testid or key
                                // Streamlit textareas typically have data-testid="stTextArea"
                                const parentDoc = window.parent.document;
                                
                                // Try multiple selectors to find the textarea
                                let textarea = null;
                                
                                // Method 1: Find by data-testid
                                textarea = parentDoc.querySelector('textarea[data-testid="stTextArea"]');
                                
                                // Method 2: Find by key attribute (if Streamlit sets it)
                                if (!textarea) {
                                    textarea = parentDoc.querySelector('textarea[key="coord_json_input_step2"]');
                                }
                                
                                // Method 3: Find by label text containing "Paste coordinates JSON here"
                                if (!textarea) {
                                    const labels = parentDoc.querySelectorAll('label');
                                    for (let label of labels) {
                                        const labelText = label.textContent || '';
                                        if (labelText.includes('Paste coordinates JSON') || labelText.includes('Coordinates JSON')) {
                                            // Find the textarea associated with this label
                                            const labelFor = label.getAttribute('for');
                                            if (labelFor) {
                                                textarea = parentDoc.getElementById(labelFor);
                                            }
                                            // Or find the next textarea sibling or in parent container
                                            if (!textarea) {
                                                // Try to find textarea in the same container as the label
                                                let container = label.closest('[class*="stTextArea"], [class*="element-container"], div');
                                                if (container) {
                                                    textarea = container.querySelector('textarea');
                                                }
                                                // Or find the next textarea sibling
                                                if (!textarea) {
                                                    let next = label.nextElementSibling;
                                                    let depth = 0;
                                                    while (next && !textarea && depth < 10) {
                                                        if (next.tagName === 'TEXTAREA') {
                                                            textarea = next;
                                                            break;
                                                        }
                                                        // Also search within the sibling
                                                        if (next.querySelector) {
                                                            textarea = next.querySelector('textarea');
                                                        }
                                                        next = next.nextElementSibling;
                                                        depth++;
                                                    }
                                                }
                                            }
                                            if (textarea) {
                                                console.log('üìù Found textarea via label:', labelText);
                                                break;
                                            }
                                        }
                                    }
                                }
                                
                                // Method 4: Find by placeholder text
                                if (!textarea) {
                                    const allTextareas = parentDoc.querySelectorAll('textarea');
                                    for (let ta of allTextareas) {
                                        const placeholder = ta.getAttribute('placeholder') || '';
                                        if (placeholder.includes('Save Changes') || placeholder.includes('coordinates JSON')) {
                                            textarea = ta;
                                            console.log('üìù Found textarea via placeholder:', placeholder.substring(0, 50));
                                            break;
                                        }
                                    }
                                }
                                
                                // Method 5: Find any textarea in the Streamlit page (fallback)
                                if (!textarea) {
                                    const allTextareas = parentDoc.querySelectorAll('textarea');
                                    console.log('üìù Total textareas found:', allTextareas.length);
                                    
                                    // Filter to only visible textareas
                                    const visibleTextareas = Array.from(allTextareas).filter(ta => {
                                        const style = window.parent.getComputedStyle(ta);
                                        const isVisible = style.display !== 'none' && style.visibility !== 'hidden' && ta.offsetHeight > 0;
                                        if (isVisible) {
                                            console.log('üìù Visible textarea found:', {
                                                id: ta.id,
                                                placeholder: ta.placeholder ? ta.placeholder.substring(0, 50) : '(none)',
                                                valueLength: ta.value ? ta.value.length : 0
                                            });
                                        }
                                        return isVisible;
                                    });
                                    
                                    if (visibleTextareas.length > 0) {
                                        // Try the last visible textarea (most likely to be our target)
                                        textarea = visibleTextareas[visibleTextareas.length - 1];
                                        console.log('üìù Using last visible textarea as fallback');
                                    } else if (allTextareas.length > 0) {
                                        // Fallback to last textarea even if not visible
                                        textarea = allTextareas[allTextareas.length - 1];
                                        console.log('üìù Using last textarea as final fallback');
                                    }
                                }
                                
                                // Final check: If we found a textarea, verify it's the right one
                                // by checking if it's near the "Detect Coordinates" button
                                if (textarea) {
                                    // Try to find the "Detect Coordinates" button to verify we're in the right area
                                    const buttons = parentDoc.querySelectorAll('button');
                                    let detectButton = null;
                                    for (let btn of buttons) {
                                        if (btn.textContent && btn.textContent.includes('Detect Coordinates')) {
                                            detectButton = btn;
                                            break;
                                        }
                                    }
                                    
                                    if (detectButton) {
                                        // Check if textarea is near the button (same container or nearby)
                                        const buttonRect = detectButton.getBoundingClientRect();
                                        const textareaRect = textarea.getBoundingClientRect();
                                        const distance = Math.abs(textareaRect.top - buttonRect.top);
                                        
                                        console.log('üìù Distance between textarea and Detect button:', distance, 'px');
                                        if (distance > 500) {
                                            console.warn('‚ö†Ô∏è Textarea is far from Detect button, might be wrong one');
                                            // Try to find a textarea closer to the button
                                            const allTextareas = parentDoc.querySelectorAll('textarea');
                                            let closestTextarea = textarea;
                                            let closestDistance = distance;
                                            for (let ta of allTextareas) {
                                                const taRect = ta.getBoundingClientRect();
                                                const taDistance = Math.abs(taRect.top - buttonRect.top);
                                                if (taDistance < closestDistance) {
                                                    closestDistance = taDistance;
                                                    closestTextarea = ta;
                                                }
                                            }
                                            if (closestTextarea !== textarea) {
                                                console.log('üîÑ Switching to closer textarea');
                                                textarea = closestTextarea;
                                            }
                                        }
                                    }
                                }
                                
                                if (textarea) {
                                    console.log('üìù Found textarea:', textarea);
                                    console.log('üìù Textarea ID:', textarea.id);
                                    console.log('üìù Textarea classes:', textarea.className);
                                    console.log('üìù Textarea placeholder:', textarea.placeholder);
                                    console.log('üìù Textarea current value length:', textarea.value ? textarea.value.length : 0);
                                    console.log('üìù Textarea current value preview:', textarea.value ? textarea.value.substring(0, 100) : '(empty)');
                                    console.log('üìù JSON data length:', jsonData.length);
                                    console.log('üìù First 100 chars of JSON:', jsonData.substring(0, 100));
                                    
                                    // Make textarea tiny and unobtrusive but keep it functional
                                    // Don't use display:none or position:absolute - Streamlit needs it accessible
                                    textarea.style.height = '1px';
                                    textarea.style.minHeight = '1px';
                                    textarea.style.maxHeight = '1px';
                                    textarea.style.padding = '0';
                                    textarea.style.margin = '0';
                                    textarea.style.border = 'none';
                                    textarea.style.background = 'transparent';
                                    textarea.style.color = 'transparent';
                                    textarea.style.fontSize = '1px';
                                    textarea.style.lineHeight = '1px';
                                    textarea.style.overflow = 'hidden';
                                    textarea.style.resize = 'none';
                                    // Keep it in normal flow but invisible
                                    
                                    // Hide the label
                                    const label = textarea.previousElementSibling;
                                    if (label && label.tagName === 'LABEL') {
                                        label.style.display = 'none';
                                    }
                                    
                                    const labelInContainer = textarea.closest('div[data-testid="stVerticalBlock"]')?.querySelector('label');
                                    if (labelInContainer) {
                                        labelInContainer.style.display = 'none';
                                    }
                                    
                                    // Ensure value is accessible to Streamlit
                                    // Force a final sync
                                    setTimeout(function() {
                                        if (textarea.value !== jsonData) {
                                            textarea.value = jsonData;
                                            textarea.dispatchEvent(new Event('input', { bubbles: true }));
                                            textarea.dispatchEvent(new Event('change', { bubbles: true }));
                                        }
                                    }, 50);
                                    
                                    // Check if this textarea already has our data (to avoid duplicate fills)
                                    const hasOurData = textarea.value && textarea.value.includes('"plots"') && textarea.value.length > 1000;
                                    if (hasOurData) {
                                        console.log('‚ö†Ô∏è Textarea already contains plot data, verifying it matches...');
                                        try {
                                            const existingData = JSON.parse(textarea.value);
                                            const newData = JSON.parse(jsonData);
                                            if (existingData.plots && newData.plots) {
                                                console.log('üìä Existing plots count:', existingData.plots.length);
                                                console.log('üìä New plots count:', newData.plots.length);
                                                if (existingData.plots.length === newData.plots.length) {
                                                    console.log('‚úÖ Textarea already has correct data, skipping fill');
                                                    attempts = maxAttempts;
                                                    return;
                                                } else {
                                                    console.log('üîÑ Plot count differs, updating textarea...');
                                                }
                                            }
                                        } catch (e) {
                                            console.log('‚ö†Ô∏è Could not parse existing data, proceeding with fill:', e);
                                        }
                                    }
                                    
                                    // Method 1: Use React's value setter if available (for React-controlled inputs)
                                    let valueSet = false;
                                    try {
                                        // Get the React fiber/node for this element
                                        const reactKey = Object.keys(textarea).find(key => key.startsWith('__reactFiber') || key.startsWith('__reactInternalInstance'));
                                        if (reactKey) {
                                            console.log('‚öõÔ∏è Found React instance, using React setter');
                                            const reactFiber = textarea[reactKey];
                                            if (reactFiber && reactFiber.memoizedProps) {
                                                // Try to find the onChange handler
                                                const props = reactFiber.memoizedProps;
                                                if (props.onChange || props.onInput) {
                                                    // Create a synthetic event
                                                    const syntheticEvent = {
                                                        target: textarea,
                                                        currentTarget: textarea,
                                                        bubbles: true,
                                                        cancelable: true
                                                    };
                                                    textarea.value = jsonData;
                                                    if (props.onChange) {
                                                        props.onChange(syntheticEvent);
                                                        valueSet = true;
                                                        console.log('‚úÖ Used React onChange handler');
                                                    } else if (props.onInput) {
                                                        props.onInput(syntheticEvent);
                                                        valueSet = true;
                                                        console.log('‚úÖ Used React onInput handler');
                                                    }
                                                }
                                            }
                                        }
                                    } catch (e) {
                                        console.log('‚ö†Ô∏è React setter approach failed:', e);
                                    }
                                    
                                    // Method 2: Standard DOM manipulation (fallback or if React method didn't work)
                                    if (!valueSet) {
                                        // Set the JSON value using native setter
                                        const nativeInputValueSetter = Object.getOwnPropertyDescriptor(window.HTMLTextAreaElement.prototype, 'value');
                                        if (nativeInputValueSetter && nativeInputValueSetter.set) {
                                            nativeInputValueSetter.set.call(textarea, jsonData);
                                            console.log('‚úÖ Used native value setter');
                                        } else {
                                            textarea.value = jsonData;
                                            console.log('‚úÖ Used direct value assignment');
                                        }
                                    }
                                    
                                    // Verify the value was set
                                    if (textarea.value === jsonData || textarea.value.length === jsonData.length) {
                                        console.log('‚úÖ Value set successfully, length:', textarea.value.length);
                                    } else {
                                        console.warn('‚ö†Ô∏è Value mismatch! Expected length:', jsonData.length, 'Got length:', textarea.value ? textarea.value.length : 0);
                                        // Try setting again with native setter
                                        try {
                                            const nativeInputValueSetter = Object.getOwnPropertyDescriptor(window.HTMLTextAreaElement.prototype, 'value').set;
                                            nativeInputValueSetter.call(textarea, jsonData);
                                            console.log('üîÑ Retried with native setter');
                                        } catch (e) {
                                            textarea.value = jsonData;
                                        }
                                    }
                                    
                                    // Dispatch multiple event types for maximum compatibility
                                    // These events are critical for React to detect the change
                                    const eventsToDispatch = [
                                        new Event('input', { bubbles: true, cancelable: true }),
                                        new Event('change', { bubbles: true, cancelable: true })
                                    ];
                                    
                                    // Try InputEvent (more React-like)
                                    try {
                                        eventsToDispatch.push(new InputEvent('input', {
                                            bubbles: true,
                                            cancelable: true,
                                            inputType: 'insertText',
                                            data: jsonData
                                        }));
                                    } catch (e) {
                                        // InputEvent might not be available
                                    }
                                    
                                    // Dispatch all events
                                    eventsToDispatch.forEach(event => {
                                        textarea.dispatchEvent(event);
                                    });
                                    console.log('‚úÖ Dispatched', eventsToDispatch.length, 'events');
                                    
                                    // Trigger focus/blur sequence to ensure Streamlit processes it
                                    // Don't scroll - textarea is hidden
                                    textarea.focus();
                                    
                                    // Small delay before blur to let Streamlit process
                                    setTimeout(function() {
                                        // Verify value is still set
                                        if (textarea.value !== jsonData && textarea.value.length !== jsonData.length) {
                                            console.warn('‚ö†Ô∏è Value was reset! Re-setting...');
                                            const nativeInputValueSetter = Object.getOwnPropertyDescriptor(window.HTMLTextAreaElement.prototype, 'value').set;
                                            nativeInputValueSetter.call(textarea, jsonData);
                                            textarea.dispatchEvent(new Event('input', { bubbles: true }));
                                            textarea.dispatchEvent(new Event('change', { bubbles: true }));
                                        }
                                        
                                        // Try one more time to trigger React update by simulating user input
                                        // This is a more aggressive approach for React-controlled inputs
                                        try {
                                            // Clear and re-set to force React to recognize the change
                                            textarea.value = '';
                                            textarea.dispatchEvent(new Event('input', { bubbles: true }));
                                            
                                            // Small delay then set the full value
                                            setTimeout(function() {
                                                const nativeInputValueSetter = Object.getOwnPropertyDescriptor(window.HTMLTextAreaElement.prototype, 'value').set;
                                                nativeInputValueSetter.call(textarea, jsonData);
                                                
                                                // Dispatch all events again
                                                textarea.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
                                                textarea.dispatchEvent(new Event('change', { bubbles: true, cancelable: true }));
                                                
                                                // Try InputEvent
                                                try {
                                                    textarea.dispatchEvent(new InputEvent('input', {
                                                        bubbles: true,
                                                        cancelable: true,
                                                        inputType: 'insertText'
                                                    }));
                                                } catch (e) {}
                                                
                                                textarea.blur();
                                                
                                                // Final verification
                                                verifyAndLogFinalValue();
                                            }, 50);
                                        } catch (e) {
                                            console.log('‚ö†Ô∏è Aggressive React update failed, using standard approach:', e);
                                            textarea.blur();
                                            
                                            // One more attempt to trigger change after blur
                                            textarea.dispatchEvent(new Event('change', { bubbles: true, cancelable: true }));
                                            
                                            // Final verification
                                            verifyAndLogFinalValue();
                                        }
                                        
                                        function verifyAndLogFinalValue() {
                                            // Final verification - check actual displayed value
                                            const finalValue = textarea.value;
                                            console.log('üìù Final textarea value length:', finalValue ? finalValue.length : 0);
                                            console.log('üìù Final value first 200 chars:', finalValue ? finalValue.substring(0, 200) : '(empty)');
                                            
                                            // Check if the value contains all plots
                                            try {
                                                const parsed = JSON.parse(finalValue);
                                                if (parsed.plots) {
                                                    console.log('üìä Final value contains', parsed.plots.length, 'plots');
                                                    const plotIds = parsed.plots.map(p => p.id || p.plot_number || 'unknown');
                                                    console.log('üìä Plot IDs in final value (first 10):', plotIds.slice(0, 10).join(', '), '...');
                                                    console.log('üìä Plot IDs in final value (last 10):', plotIds.slice(-10).join(', '));
                                                    
                                                    // Check for new plots (e.g., Plot 82)
                                                    const newPlots = parsed.plots.filter(p => {
                                                        const num = p.plot_number || (p.id ? parseInt(p.id.replace(/[^0-9]/g, '')) : 0);
                                                        return num > 80;
                                                    });
                                                    if (newPlots.length > 0) {
                                                        console.log('üÜï New plots found in final value:', newPlots.map(p => p.id || p.plot_number));
                                                    } else {
                                                        console.warn('‚ö†Ô∏è No new plots (e.g., Plot 82) found in final value!');
                                                        console.warn('‚ö†Ô∏è This suggests the textarea might not have the full data');
                                                    }
                                                    
                                                    // Verify we have the expected number of plots
                                                    const expectedPlotCount = data.length; // data is the plots array from showCopyArea
                                                    if (parsed.plots.length !== expectedPlotCount) {
                                                        console.error('‚ùå Plot count mismatch! Expected:', expectedPlotCount, 'Got:', parsed.plots.length);
                                                        console.error('‚ùå The textarea might not have been updated correctly');
                                                    } else {
                                                        console.log('‚úÖ Plot count matches expected:', expectedPlotCount);
                                                    }
                                                }
                                            } catch (e) {
                                                console.warn('‚ö†Ô∏è Could not parse final value:', e);
                                            }
                                            
                                            if (finalValue && finalValue.length > 0) {
                                                console.log('‚úÖ Auto-filled Streamlit textarea with JSON data (length: ' + finalValue.length + ')');
                                                // Textarea is hidden, no need to update header
                                                
                                                // Stop retrying since we found and filled it
                                                attempts = maxAttempts;
                                            } else {
                                                console.error('‚ùå Textarea appears empty after setting value!');
                                                console.error('‚ùå This might be a Streamlit React issue - try manually pasting');
                                            }
                                        }
                                    }, 150);
                                } else {
                                    console.warn('‚ö†Ô∏è Attempt', attempts, '- Could not find Streamlit textarea');
                                    if (attempts === maxAttempts) {
                                        console.warn('‚ö†Ô∏è Total textareas found:', parentDoc.querySelectorAll('textarea').length);
                                        console.warn('‚ö†Ô∏è All textareas:', Array.from(parentDoc.querySelectorAll('textarea')).map(t => ({
                                            id: t.id,
                                            valueLength: t.value ? t.value.length : 0,
                                            placeholder: t.placeholder
                                        })));
                                    }
                                }
                            } catch (e) {
                                console.warn('‚ö†Ô∏è Could not auto-fill textarea (may be cross-origin restriction):', e);
                            }
                            
                            // If we didn't find it and haven't exceeded max attempts, try again
                            // Note: textarea variable is scoped to the try block, so we check attempts
                            if (attempts < maxAttempts) {
                                // Check if we actually found and filled a textarea by looking for one with our JSON
                                const parentDoc = window.parent.document;
                                const allTextareas = parentDoc.querySelectorAll('textarea');
                                let foundFilled = false;
                                for (let ta of allTextareas) {
                                    if (ta.value && ta.value.includes('"plots"') && ta.value.length > 100) {
                                        foundFilled = true;
                                        break;
                                    }
                                }
                                
                                if (!foundFilled) {
                                    setTimeout(tryAutoFill, 200 * attempts); // Exponential backoff
                                } else {
                                    console.log('‚úÖ Textarea already filled, stopping retries');
                                }
                            } else if (attempts >= maxAttempts) {
                                console.error('‚ùå Failed to find or fill textarea after', maxAttempts, 'attempts');
                            }
                        }
                        
                        // Start first attempt after initial delay
                        setTimeout(tryAutoFill, 300);
                    }
                } catch (e) {
                    console.warn('‚ö†Ô∏è Error accessing parent window:', e);
                }
                
                // Already hidden, no need for auto-hide timer
            }
            
            console.log('Changes saved:', updatedPlots.length, 'plots updated');
            console.log('Coordinates JSON:', JSON.stringify(updatedPlots));
            
            // Trigger automatic image regeneration by posting message
            try {
                if (window.parent) {
                    window.parent.postMessage({
                        type: 'regenerate_image_request',
                        plots: updatedPlots,
                        timestamp: Date.now()
                    }, '*');
                }
            } catch (e) {
                console.error('Failed to send regeneration request:', e);
            }
        }
        
        function enableMergeMode() {
            mergeMode = !mergeMode;
            createMode = false;
            deleteMode = false;
            selectedPointsForMerge = [];
            selectedPlotForDelete = null;
            const mergeBtn = document.getElementById('merge-btn');
            const deleteBtn = document.getElementById('delete-btn');
            const createBtn = document.getElementById('create-btn');
            if (mergeMode) {
                mergeBtn.textContent = 'Merge';
                mergeBtn.style.backgroundColor = '#f44336';
                canvas.defaultCursor = 'pointer';
                canvas.hoverCursor = 'pointer';
                if (deleteBtn) deleteBtn.style.opacity = '0.5';
                if (createBtn) createBtn.style.opacity = '0.5';
                // Make ALL circles on canvas clickable (including newly created ones)
                // Get all circles from plotPoints and also check canvas directly
                const allCircles = [];
                Object.values(plotPoints).flat().forEach(circle => {
                    allCircles.push(circle);
                });
                // Also get any circles directly from canvas that might not be in plotPoints yet
                canvas.getObjects().forEach(obj => {
                    if (obj.type === 'circle' && obj.plotId && allCircles.indexOf(obj) === -1) {
                        allCircles.push(obj);
                    }
                });
                // Make all circles clickable
                allCircles.forEach(circle => {
                    circle.set({ 
                        evented: true,
                        selectable: true,
                        hoverCursor: 'pointer'
                    });
                });
            } else {
                mergeBtn.textContent = 'Merge';
                mergeBtn.style.backgroundColor = '#FF9800';
                canvas.defaultCursor = 'default';
                canvas.hoverCursor = 'default';
                if (deleteBtn) deleteBtn.style.opacity = '1';
                if (createBtn) createBtn.style.opacity = '1';
                // Reset all point colors - get all circles from canvas
                const allCircles = [];
                Object.values(plotPoints).flat().forEach(circle => {
                    allCircles.push(circle);
                });
                canvas.getObjects().forEach(obj => {
                    if (obj.type === 'circle' && obj.plotId && allCircles.indexOf(obj) === -1) {
                        allCircles.push(obj);
                    }
                });
                allCircles.forEach(circle => {
                    circle.set({ fill: '#FF0000', stroke: '#FFFFFF', strokeWidth: 2 });
                });
                canvas.renderAll();
            }
        }
        
        function togglePointForMerge(circle) {
            if (!mergeMode) return;
            
            const index = selectedPointsForMerge.indexOf(circle);
            if (index > -1) {
                // Deselect
                selectedPointsForMerge.splice(index, 1);
                circle.set({ fill: '#FF0000', stroke: '#FFFFFF', strokeWidth: 2 });
            } else {
                // Select
                if (selectedPointsForMerge.length < 2) {
                    selectedPointsForMerge.push(circle);
                    circle.set({ fill: '#00FF00', stroke: '#000000', strokeWidth: 3 });
                } else {
                    // Already have 2 selected, replace first
                    const firstPoint = selectedPointsForMerge[0];
                    firstPoint.set({ fill: '#FF0000', stroke: '#FFFFFF', strokeWidth: 2 });
                    selectedPointsForMerge.shift();
                    selectedPointsForMerge.push(circle);
                    circle.set({ fill: '#00FF00', stroke: '#000000', strokeWidth: 3 });
                }
            }
            
            // Force immediate render
            canvas.renderAll();
            
            // Update merge button text
            const mergeBtn = document.getElementById('merge-btn');
            if (mergeBtn) {
                mergeBtn.textContent = 'Merge';
                if (selectedPointsForMerge.length === 2) {
                    mergeBtn.style.backgroundColor = '#4CAF50';
                } else {
                    mergeBtn.style.backgroundColor = '#FF9800';
                }
            }
            
            console.log('Merge selection:', selectedPointsForMerge.length, 'points selected');
        }
        
        // Setup button handlers
        function setupButtonHandlers() {
            const saveBtn = document.getElementById('save-btn');
            const mergeBtn = document.getElementById('merge-btn');
            const createBtn = document.getElementById('create-btn');
            const deleteBtn = document.getElementById('delete-btn');
            
            if (saveBtn) {
                saveBtn.onclick = saveChanges;
            }
            
            if (mergeBtn) {
                mergeBtn.onclick = function() {
                    // Merge works with Ctrl+Click selection (no mode needed)
                    if (selectedPointsForMerge.length === 2) {
                        mergeSelectedPoints();
                    } else {
                        alert('Please select exactly 2 points using Ctrl+Click, then click Merge.');
                    }
                };
            }
            
            if (createBtn) {
                createBtn.onclick = function() {
                    // Check total points (selected existing + newly created)
                    const totalPoints = selectedExistingCircles.length + newPlotPoints.length;
                    if (createMode && totalPoints >= 3) {
                        createNewPlot();
                    } else {
                        enableCreateMode();
                    }
                };
            }
            
            if (deleteBtn) {
                deleteBtn.onclick = function() {
                    // LIFO: If in create mode and there are newly created points, delete the last one (most recent)
                    if (createMode && newPlotPoints.length > 0) {
                        const lastPoint = newPlotPoints.pop(); // Remove last point (LIFO)
                        canvas.remove(lastPoint);
                        canvas.renderAll();
                        
                        // Update button text to show remaining points
                        updateCreateButtonText();
                        console.log('Deleted last created point. Remaining points:', newPlotPoints.length);
                        return;
                    }
                    
                    // Check if a plot is selected
                    if (selectedPlotForDelete) {
                        // Show confirmation dialog for the selected plot
                        showDeleteConfirmation(selectedPlotForDelete);
                    } else {
                        // No plot selected - show temporary message on button
                        const originalText = deleteBtn.textContent;
                        deleteBtn.textContent = '‚ö†Ô∏è Select a plot first';
                        deleteBtn.style.backgroundColor = '#ff9800';
                        setTimeout(() => {
                            deleteBtn.textContent = originalText;
                            deleteBtn.style.backgroundColor = '#f44336';
                        }, 2000);
                    }
                };
            }
            
            // Setup delete confirmation dialog handlers
            const confirmDeleteBtn = document.getElementById('confirm-delete-btn');
            const cancelDeleteBtn = document.getElementById('cancel-delete-btn');
            
            if (confirmDeleteBtn) {
                confirmDeleteBtn.onclick = function() {
                    if (selectedPlotForDelete) {
                        hideDeleteConfirmation();
                        deletePlot(selectedPlotForDelete);
                    }
                };
            }
            
            if (cancelDeleteBtn) {
                cancelDeleteBtn.onclick = function() {
                    hideDeleteConfirmation();
                };
            }
            
            // Close delete dialog when clicking on overlay (outside the dialog)
            const deleteDialogOverlay = document.getElementById('delete-dialog-overlay');
            if (deleteDialogOverlay) {
                deleteDialogOverlay.onclick = function(e) {
                    // Only close if clicking directly on overlay, not on the dialog itself
                    if (e.target === deleteDialogOverlay) {
                        hideDeleteConfirmation();
                    }
                };
            }
            
            // Setup Move Dots button handler
            const moveDotsBtn = document.getElementById('move-dots-btn');
            if (moveDotsBtn) {
                moveDotsBtn.onclick = function() {
                    if (selectedDotsForMove.length > 0) {
                        showMoveDotsDialog();
                    }
                };
            }
            
            // Setup pixel move dialog handlers
            const applyMoveBtn = document.getElementById('apply-move-btn');
            const cancelMoveBtn = document.getElementById('cancel-move-btn');
            const pixelMoveOverlay = document.getElementById('pixel-move-overlay');
            
            if (applyMoveBtn) {
                applyMoveBtn.onclick = function() {
                    applyPixelMove();
                };
            }
            
            if (cancelMoveBtn) {
                cancelMoveBtn.onclick = function() {
                    hideMoveDotsDialog();
                };
            }
            
            if (pixelMoveOverlay) {
                pixelMoveOverlay.onclick = function(e) {
                    if (e.target === pixelMoveOverlay) {
                        hideMoveDotsDialog();
                    }
                };
            }
        }
        
        // Initialize button handlers when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', setupButtonHandlers);
        } else {
            setupButtonHandlers();
        }
        
        // Functions for pixel move feature
        function updateMoveButtonCounter() {
            const moveDotsBtn = document.getElementById('move-dots-btn');
            if (moveDotsBtn) {
                moveDotsBtn.textContent = 'Move';
                if (selectedDotsForMove.length > 0) {
                    moveDotsBtn.style.backgroundColor = '#28a745'; // Success green when dots selected
                } else {
                    moveDotsBtn.style.backgroundColor = '#17a2b8'; // Info blue when none selected
                }
            }
        }
        
        function showMoveDotsDialog() {
            const pixelMoveOverlay = document.getElementById('pixel-move-overlay');
            const moveDxInput = document.getElementById('move-dx');
            const moveDyInput = document.getElementById('move-dy');
            
            if (pixelMoveOverlay) {
                pixelMoveOverlay.style.display = 'block';
            }
            
            if (moveDxInput) moveDxInput.value = '0';
            if (moveDyInput) moveDyInput.value = '0';
            
            // Add Enter key support for both inputs
            const handleEnterKey = function(e) {
                if (e.key === 'Enter') {
                    applyPixelMove();
                }
            };
            
            if (moveDxInput) {
                moveDxInput.onkeypress = handleEnterKey;
                setTimeout(() => moveDxInput.focus(), 100);
            }
            
            if (moveDyInput) {
                moveDyInput.onkeypress = handleEnterKey;
            }
        }
        
        function hideMoveDotsDialog() {
            const pixelMoveOverlay = document.getElementById('pixel-move-overlay');
            if (pixelMoveOverlay) {
                pixelMoveOverlay.style.display = 'none';
            }
            // Note: We don't clear selection here so user can re-open and adjust values
        }
        
        function clearDotSelection() {
            // Clear all selected dots
            selectedDotsForMove.forEach(dot => {
                dot.set({ stroke: '#FFFFFF', strokeWidth: 2 });
                dot.setCoords();
            });
            selectedDotsForMove = [];
            updateMoveButtonCounter();
            canvas.renderAll();
        }
        
        function applyPixelMove() {
            const moveDxInput = document.getElementById('move-dx');
            const moveDyInput = document.getElementById('move-dy');
            
            if (!moveDxInput || !moveDyInput) {
                console.error('Move inputs not found');
                return;
            }
            
            const dx = parseFloat(moveDxInput.value) || 0;
            const dy = parseFloat(moveDyInput.value) || 0;
            
            if (dx === 0 && dy === 0) {
                hideMoveDotsDialog();
                return;
            }
            
            console.log(`Moving ${selectedDotsForMove.length} dots by dx=${dx}, dy=${dy}`);
            
            // Move each selected dot
            selectedDotsForMove.forEach(dot => {
                // Store original position if not already stored (for undo/zoom features)
                if (!dot.originalLeft) {
                    dot.originalLeft = dot.left;
                    dot.originalTop = dot.top;
                }
                
                // Update the original position (since we want to move from current position)
                dot.originalLeft = dot.left;
                dot.originalTop = dot.top;
                
                // Apply movement
                dot.set({
                    left: dot.left + dx,
                    top: dot.top + dy
                });
                
                // Update original to reflect the new position
                dot.originalLeft = dot.left;
                dot.originalTop = dot.top;
                
                dot.setCoords();
                
                // Update the corresponding polygon if this dot belongs to a plot
                if (dot.plotId) {
                    updatePolygon(dot.plotId);
                }
            });
            
            // Clear selection and reset stroke
            selectedDotsForMove.forEach(dot => {
                dot.set({ stroke: '#FFFFFF', strokeWidth: 2 });
                dot.setCoords();
            });
            selectedDotsForMove = [];
            updateMoveButtonCounter();
            
            canvas.renderAll();
            hideMoveDotsDialog();
            
            // Show success message
            const moveDotsBtn = document.getElementById('move-dots-btn');
            if (moveDotsBtn) {
                const originalText = moveDotsBtn.textContent;
                moveDotsBtn.textContent = 'Move';
                moveDotsBtn.style.backgroundColor = '#4CAF50';
                setTimeout(() => {
                    moveDotsBtn.textContent = originalText;
                    moveDotsBtn.style.backgroundColor = '#2196F3';
                }, 2000);
            }
        }
        
        function mergeSelectedPoints() {
            if (selectedPointsForMerge.length !== 2) {
                alert('Please select exactly 2 points to merge. Click on points to select them.');
                return;
            }
            
            const point1 = selectedPointsForMerge[0];
            const point2 = selectedPointsForMerge[1];
            
            // Check if points are close enough (within 20 pixels)
            const distance = Math.sqrt(
                Math.pow(point1.left - point2.left, 2) + 
                Math.pow(point1.top - point2.top, 2)
            );
            
            if (distance > 20) {
                alert('Points are too far apart. Please move them closer together first.');
                return;
            }
            
            // Average the positions
            const avgX = (point1.left + point2.left) / 2;
            const avgY = (point1.top + point2.top) / 2;
            
            // Move both points to the average position
            point1.set({ left: avgX, top: avgY });
            point2.set({ left: avgX, top: avgY });
            
            // Update polygons if in lines mode
            if (mode === 'lines') {
                if (point1.plotId) updatePolygon(point1.plotId);
                if (point2.plotId && point2.plotId !== point1.plotId) updatePolygon(point2.plotId);
            }
            
            // Reset merge selection and update button
            selectedPointsForMerge = [];
            updateMergeButtonText();
            
            canvas.renderAll();
            
            console.log('Points merged at:', avgX, avgY);
        }
        
        // Update merge button text based on selection
        function updateMergeButtonText() {
            const mergeBtn = document.getElementById('merge-btn');
            if (mergeBtn) {
                mergeBtn.textContent = 'Merge';
                if (selectedPointsForMerge.length === 2) {
                    mergeBtn.style.backgroundColor = '#4CAF50';
                } else {
                    mergeBtn.style.backgroundColor = '#FF9800';
                }
            }
        }
        
        function enableCreateMode() {
            createMode = !createMode;
            mergeMode = false;
            deleteMode = false;
            newPlotPoints = [];
            selectedExistingCircles = []; // Reset selected existing circles
            selectedPlotForDelete = null;
            pendingPlotData = null;
            const createBtn = document.getElementById('create-btn');
            const deleteBtn = document.getElementById('delete-btn');
            if (createMode) {
                createBtn.textContent = 'Create';
                createBtn.style.backgroundColor = '#f44336';
                canvas.defaultCursor = 'crosshair';
                canvas.hoverCursor = 'crosshair';
                canvas.on('mouse:down', handleCreatePlotClick);
                // Disable selection and panning during create mode
                canvas.selection = false;
                canvas.defaultCursor = 'crosshair';
                // Prevent canvas from being moved
                canvas.allowTouchScrolling = false;
                if (deleteBtn) deleteBtn.style.opacity = '0.5';
                
                // Update button text to show instructions
                updateCreateButtonText();
            } else {
                createBtn.textContent = 'Create';
                createBtn.style.backgroundColor = '#4CAF50';
                canvas.defaultCursor = 'default';
                canvas.hoverCursor = 'default';
                canvas.off('mouse:down', handleCreatePlotClick);
                canvas.selection = true;
                if (deleteBtn) deleteBtn.style.opacity = '1';
                // Clear any temporary points
                newPlotPoints.forEach(point => canvas.remove(point));
                newPlotPoints = [];
                canvas.renderAll();
            }
        }
        
        function handleCreatePlotClick(options) {
            if (!createMode) return;
            
            // Prevent default canvas behavior and panning
            if (options.e) {
                options.e.preventDefault();
                options.e.stopPropagation();
                options.e.stopImmediatePropagation();
            }
            
            // Don't create on existing plot elements (but allow clicking on background and circles)
            // Circles are handled by their own mousedown handler in create mode
            // Polygons are handled by their own mousedown handler in create mode (with line projection)
            if (options.target && options.target !== canvas.backgroundImage) {
                // Allow clicking on circles (they handle their own selection)
                if (options.target.type === 'circle') {
                    return; // Let circle handler deal with it
                }
                // Block clicks on polygons (they handle their own projection logic) and text
                if (options.target.plotId || options.target.type === 'polygon' || options.target.type === 'text') {
                    return;
                }
            }
            
            // If we have selected existing circles, we can create additional points
            // If no existing circles selected, create new points as before
            
            // CRITICAL: Convert mouse coordinates to world coordinates
            // This ensures geometry calculations are done in world space, independent of zoom/pan
            const worldPoint = mouseToWorldCoordinates(canvas, options.e);
            
            // CRITICAL: Use the same scale/offset as existing plots (stored in circles)
            // Background image scaling does NOT affect coordinate space - we use stored values from circles
            // This ensures consistency - new plots use the same coordinate system as existing ones
            let scale = 1;
            let offsetX = 0;
            let offsetY = 0;
            
            // Get scale/offset from existing circles if available
            // CRITICAL: Always prefer stored values from circles, not background image transformations
            const allExistingCircles = Object.values(plotPoints).flat();
            if (allExistingCircles.length > 0) {
                // Use the stored scale/offset from existing circles (consistent across all)
                // These values are independent of background image scaling
                scale = allExistingCircles[0].scale || 1;
                offsetX = allExistingCircles[0].offsetX || 0;
                offsetY = allExistingCircles[0].offsetY || 0;
            } else {
                // Fallback to background image original values if no existing circles
                // Use originalScaleX/originalLeft to avoid zoom/pan transformations affecting coordinates
                const bgImg = window.canvasBgImg || canvas.backgroundImage;
                if (bgImg) {
                    // Use original values, not current transformed values
                    // This ensures background image scaling doesn't affect coordinate space
                    scale = bgImg.originalScaleX || bgImg.scaleX || 1;
                    offsetX = bgImg.originalLeft || bgImg.left || 0;
                    offsetY = bgImg.originalTop || bgImg.top || 0;
                }
            }
            
            // Check if the new point is too close to existing points from OTHER plots
            // CRITICAL: Allow points to be close to each other when creating the same plot
            // Only prevent points that are too close to points from DIFFERENT plots
            const minDistance = 15; // Minimum distance in canvas pixels (reduced to allow closer points)
            let tooClose = false;
            
            // Check against all existing plot points from OTHER plots (not the current plot being created)
            // This prevents accidentally clicking on points from other plots, but allows creating points close together
            Object.values(plotPoints).flat().forEach(existingCircle => {
                // Skip if it's a new plot point (same plot being created) or a selected existing circle
                if (existingCircle.plotId !== 'new_plot' && !selectedExistingCircles.includes(existingCircle)) {
                    const dx = worldPoint.x - existingCircle.left;
                    const dy = worldPoint.y - existingCircle.top;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < minDistance) {
                        tooClose = true;
                        console.log('Point too close to existing point from plot', existingCircle.plotId, 'distance:', distance);
                    }
                }
            });
            
            // CRITICAL: DO NOT check against other newPlotPoints - allow creating points close together
            // This was preventing users from adding multiple points to the same plot
            // Users should be able to create points as close as they want when building a plot
            
            if (tooClose) {
                console.log('Point too close to existing point from another plot, skipping');
                return; // Don't create point if too close to points from other plots
            }
            
            console.log('Creating new point', newPlotPoints.length + 1, 'at world coords:', worldPoint.x, worldPoint.y);
            
            // Create a new point - ensure it's on top of everything
            // Calculate original coordinates from world coordinates
            const originalX = Math.round((worldPoint.x - offsetX) / scale);
            const originalY = Math.round((worldPoint.y - offsetY) / scale);
            
            const circle = new fabric.Circle({
                left: worldPoint.x,
                top: worldPoint.y,
                radius: 4,
                fill: '#0000FF', // Blue for new points
                stroke: '#FFFFFF',
                strokeWidth: 2,
                originX: 'center',
                originY: 'center',
                selectable: true,
                hasControls: false,
                hasBorders: true,
                borderColor: '#0066CC',
                cornerColor: '#0066CC',
                cornerSize: 8,
                plotId: 'new_plot',
                pointIndex: newPlotPoints.length,
                scale: scale,
                offsetX: offsetX,
                offsetY: offsetY,
                originalX: originalX,  // Store original coordinates immediately
                originalY: originalY,  // Store original coordinates immediately
                evented: true,
                hoverCursor: 'move',
                moveCursor: 'move',
                objectCaching: false,     // Disable caching for accurate coordinate handling
                noScaleCache: true,      // Disable scale cache
                statefullCache: false    // Disable stateful cache
            });
            
            circle.on('moving', function(e) {
                // Update original coordinates when circle is moved
                // Use the scale and offset stored when the circle was created
                // This ensures consistency even if background image position changes
                const storedScale = this.scale || 1;
                const storedOffsetX = this.offsetX || 0;
                const storedOffsetY = this.offsetY || 0;
                
                // Calculate original coordinates using the stored scale/offset
                // This ensures coordinates are always relative to the original image
                this.originalX = Math.round((this.left - storedOffsetX) / storedScale);
                this.originalY = Math.round((this.top - storedOffsetY) / storedScale);
                
                // Update selection box coordinates to prevent offset
                // CRITICAL: Must call setCoords() to ensure selection boxes align correctly
                this.setCoords();
                
                canvas.renderAll();
            });
            
            newPlotPoints.push(circle);
            canvas.add(circle);
            // Ensure new point is always on top
            canvas.bringToFront(circle);
            canvas.renderAll();
            
            // Update button text to show progress
            updateCreateButtonText();
        }
        
        function updateCreateButtonText() {
            const createBtn = document.getElementById('create-btn');
            if (!createBtn) return;
            createBtn.textContent = 'Create';
        }
        
        // Function to find common points between new plot and existing plots
        function findCommonPoints(newPlotPoints, existingPlots, threshold = 15) {
            const commonPoints = [];
            const bgImg = canvas.backgroundImage;
            let scale = 1;
            let offsetX = 0;
            let offsetY = 0;
            
            if (bgImg) {
                scale = bgImg.scaleX || 1;
                offsetX = bgImg.left || 0;
                offsetY = bgImg.top || 0;
            }
            
            // Convert new plot points to canvas coordinates
            const newCanvasPoints = newPlotPoints.map(circle => ({
                x: circle.left,
                y: circle.top
            }));
            
            // Check each existing plot
            existingPlots.forEach(existingPlot => {
                const existingPlotId = existingPlot.id;
                const existingCircles = plotPoints[existingPlotId];
                
                if (!existingCircles) return;
                
                // Check each point of new plot against each point of existing plot
                newPlotPoints.forEach((newCircle, newIdx) => {
                    existingCircles.forEach((existingCircle, existingIdx) => {
                        const distance = Math.sqrt(
                            Math.pow(newCircle.left - existingCircle.left, 2) + 
                            Math.pow(newCircle.top - existingCircle.top, 2)
                        );
                        
                        if (distance < threshold) {
                            commonPoints.push({
                                newPoint: newCircle,
                                newIndex: newIdx,
                                existingPoint: existingCircle,
                                existingIndex: existingIdx,
                                existingPlotId: existingPlotId,
                                distance: distance
                            });
                        }
                    });
                });
            });
            
            return commonPoints;
        }
        
        // Function to merge common points (snap new points to existing ones)
        function mergeCommonPoints(newPlotPoints, commonPoints) {
            if (!commonPoints || !Array.isArray(commonPoints)) {
                return;
            }
            
            commonPoints.forEach(common => {
                // Only merge if this is a new point that needs to be snapped to an existing point
                // Selected existing circles are already existing points, so skip them
                if (common && common.newPoint && common.existingPoint) {
                    // Verify both objects exist and have the required properties
                    if (common.newPoint.set && 
                        typeof common.existingPoint.left !== 'undefined' && 
                        typeof common.existingPoint.top !== 'undefined') {
                        // Snap new point to existing point position
                        common.newPoint.set({
                            left: common.existingPoint.left,
                            top: common.existingPoint.top
                        });
                        common.newPoint.setCoords();
                    }
                }
                // If it's a selected existing circle (has 'circle' property instead of 'newPoint'),
                // we don't need to merge it - it's already an existing point
            });
        }
        
        // Function to auto-renumber plots based on assigned number
        function autoRenumberPlots(assignedNumber) {
            // Sort all existing plots by their current plot_number
            plotsData.sort((a, b) => (a.plot_number || 0) - (b.plot_number || 0));
            
            // Find plots that need to be renumbered (those with number >= assignedNumber)
            const plotsToRenumber = plotsData.filter(p => (p.plot_number || 0) >= assignedNumber);
            
            // Create a mapping of old IDs to new IDs
            const idMapping = {};
            
            // Renumber plots that need it
            plotsToRenumber.forEach(plot => {
                const oldPlotId = plot.id;
                const oldPlotNum = plot.plot_number || 0;
                const newPlotNum = oldPlotNum + 1;
                
                plot.plot_number = newPlotNum;
                plot.id = 'Plot ' + newPlotNum;
                
                idMapping[oldPlotId] = plot.id;
            });
            
            // Update plotPoints keys and canvas objects
            const newPlotPointsDict = {};
            
            // First, copy all existing plotPoints
            Object.keys(plotPoints).forEach(oldId => {
                if (idMapping[oldId]) {
                    // This plot needs renumbering
                    const newId = idMapping[oldId];
                    newPlotPointsDict[newId] = plotPoints[oldId];
                    // Update plotId in all circles
                    if (plotPoints[oldId]) {
                        plotPoints[oldId].forEach(circle => {
                            circle.set('plotId', newId);
                        });
                    }
                } else {
                    // Keep plots that don't need renumbering
                    newPlotPointsDict[oldId] = plotPoints[oldId];
                }
            });
            
            // Update canvas objects (text labels, polygons, etc.)
            Object.keys(idMapping).forEach(oldId => {
                const newId = idMapping[oldId];
                const newPlotNum = parseInt(newId.replace('Plot ', ''));
                
                canvas.getObjects().forEach(obj => {
                    if (obj.plotId === oldId) {
                        obj.set('plotId', newId);
                        if (obj.type === 'text') {
                            obj.set('text', String(newPlotNum));
                        }
                        if (obj.plotNumber !== undefined) {
                            obj.set('plotNumber', newPlotNum);
                        }
                    }
                });
            });
            
            // Update plotPoints dictionary
            Object.keys(plotPoints).forEach(key => {
                delete plotPoints[key];
            });
            Object.keys(newPlotPointsDict).forEach(key => {
                plotPoints[key] = newPlotPointsDict[key];
            });
        }
        
        function modifyExistingPlot(plotId, selectedCircles, newPoints) {
            console.log('modifyExistingPlot called for plotId:', plotId, 'with', selectedCircles.length, 'selected circles and', newPoints.length, 'new points');
            
            // Get all existing circles for this plot
            const existingCircles = plotPoints[plotId] || [];
            console.log('Existing circles for plot', plotId, ':', existingCircles.length);
            
            // Combine existing circles with new points
            // CRITICAL: Keep ALL existing circles - they're all part of the modified shape
            const allCircles = [...existingCircles, ...newPoints];
            console.log('Total circles after combining:', allCircles.length);
            
            // Get scale and offset for coordinate conversion
            let scale = 1;
            let offsetX = 0;
            let offsetY = 0;
            
            if (existingCircles.length > 0) {
                scale = existingCircles[0].scale || 1;
                offsetX = existingCircles[0].offsetX || 0;
                offsetY = existingCircles[0].offsetY || 0;
            } else {
                const allExistingCircles = Object.values(plotPoints).flat();
                if (allExistingCircles.length > 0) {
                    scale = allExistingCircles[0].scale || 1;
                    offsetX = allExistingCircles[0].offsetX || 0;
                    offsetY = allExistingCircles[0].offsetY || 0;
                }
            }
            
            // Convert all circles to points with original coordinates
            // CRITICAL: Use each circle's own scale/offset if available
            const points = allCircles.map(circle => {
                let originalX, originalY;
                
                // Use circle's own scale/offset if available, otherwise use global
                const circleScale = circle.scale || scale;
                const circleOffsetX = circle.offsetX !== undefined ? circle.offsetX : offsetX;
                const circleOffsetY = circle.offsetY !== undefined ? circle.offsetY : offsetY;
                
                if (circle.originalX !== undefined && circle.originalY !== undefined) {
                    originalX = circle.originalX;
                    originalY = circle.originalY;
                } else {
                    // Calculate using circle's own scale/offset
                    originalX = Math.round((circle.left - circleOffsetX) / circleScale);
                    originalY = Math.round((circle.top - circleOffsetY) / circleScale);
                    // Store for future use
                    circle.originalX = originalX;
                    circle.originalY = originalY;
                }
                return {
                    x: originalX,
                    y: originalY,
                    canvasX: circle.left,
                    canvasY: circle.top,
                    circle: circle
                };
            });
            
            // Sort points in clockwise order around centroid
            const centerX = points.reduce((sum, p) => sum + p.canvasX, 0) / points.length;
            const centerY = points.reduce((sum, p) => sum + p.canvasY, 0) / points.length;
            
            points.sort((a, b) => {
                const angleA = Math.atan2(a.canvasY - centerY, a.canvasX - centerX);
                const angleB = Math.atan2(b.canvasY - centerY, b.canvasX - centerX);
                return angleA - angleB;
            });
            
            // Update new points to have the correct plotId and properties
            // CRITICAL: Set all required properties for saving to work correctly
            newPoints.forEach((newCircle, idx) => {
                // Get the circle's current scale/offset if it exists (from when it was created)
                const circleScale = newCircle.scale || scale;
                const circleOffsetX = newCircle.offsetX !== undefined ? newCircle.offsetX : offsetX;
                const circleOffsetY = newCircle.offsetY !== undefined ? newCircle.offsetY : offsetY;
                
                // Ensure originalX and originalY are set (recalculate if missing)
                if (newCircle.originalX === undefined || newCircle.originalY === undefined) {
                    newCircle.originalX = Math.round((newCircle.left - circleOffsetX) / circleScale);
                    newCircle.originalY = Math.round((newCircle.top - circleOffsetY) / circleScale);
                }
                
                newCircle.set({
                    plotId: plotId,
                    fill: '#FF0000', // Red like existing points
                    stroke: '#FFFFFF',
                    strokeWidth: 2
                });
                
                // CRITICAL: Store properties directly on circle object (essential for saving)
                newCircle.scale = circleScale;
                newCircle.offsetX = circleOffsetX;
                newCircle.offsetY = circleOffsetY;
                
                // Add event handlers (same as existing plots)
                let circleMoved = false;
                let circleMouseDownTime = 0;
                
                newCircle.set({
                    evented: true,
                    selectable: true,
                    hoverCursor: 'pointer',
                    perPixelTargetFind: true
                });
                
                // Add comprehensive handlers (same as existing plots)
                newCircle.on('mousedown', function(e) {
                    circleMoved = false;
                    circleMouseDownTime = Date.now();
                    
                    if (e.e.ctrlKey || e.e.metaKey) {
                        e.e.stopPropagation();
                        e.e.stopImmediatePropagation();
                        const isAlreadySelected = selectedDotsForMove.includes(this);
                        if (isAlreadySelected) {
                            const index = selectedDotsForMove.indexOf(this);
                            selectedDotsForMove.splice(index, 1);
                            this.set({ stroke: '#FFFFFF', strokeWidth: 2 });
                        } else {
                            selectedDotsForMove.push(this);
                            this.set({ stroke: '#4CAF50', strokeWidth: 4 });
                        }
                        this.setCoords();
                        canvas.renderAll();
                        updateMoveButtonCounter();
                        return false;
                    }
                    
                    if (mergeMode) {
                        e.e.stopPropagation();
                        e.e.stopImmediatePropagation();
                        togglePointForMerge(this);
                        return false;
                    } else if (createMode) {
                        e.e.stopPropagation();
                        e.e.stopImmediatePropagation();
                        return false;
                    }
                });
                
                newCircle.on('mouseup', function(e) {
                    if (mergeMode) {
                        e.e.stopPropagation();
                        e.e.stopImmediatePropagation();
                        return false;
                    } else if (!createMode && !mergeMode && !circleMoved) {
                        const clickDuration = Date.now() - circleMouseDownTime;
                        if (clickDuration < 300) {
                            e.e.stopPropagation();
                            e.e.stopImmediatePropagation();
                            if (this.plotId) {
                                selectPlotForDelete(this.plotId);
                            }
                            return false;
                        }
                    }
                });
                
                newCircle.on('moving', function(e) {
                    circleMoved = true;
                    const storedScale = this.scale || 1;
                    const storedOffsetX = this.offsetX || 0;
                    const storedOffsetY = this.offsetY || 0;
                    this.originalX = Math.round((this.left - storedOffsetX) / storedScale);
                    this.originalY = Math.round((this.top - storedOffsetY) / storedScale);
                    this.setCoords();
                    if (mode === 'lines') {
                        updatePolygon(this.plotId);
                    }
                    canvas.renderAll();
                });
                
                newCircle.on('modified', function() {
                    if (mode === 'lines') {
                        updatePolygon(this.plotId);
                    }
                });
            });
            
            // Update plotPoints with reordered circles
            const reorderedCircles = points.map(p => p.circle);
            plotPoints[plotId] = reorderedCircles;
            
            console.log('‚úÖ Modified plot', plotId, '- Updated plotPoints with', reorderedCircles.length, 'circles');
            console.log('   All circles:', reorderedCircles.map((c, i) => ({ idx: i, plotId: c.plotId, left: c.left, top: c.top, originalX: c.originalX, originalY: c.originalY })));
            
            // Update plotsData - CRITICAL: This ensures the modified plot is saved
            const plotData = plotsData.find(p => p.id === plotId);
            if (plotData) {
                const updatedPoints = points.map(p => ({ x: p.x, y: p.y }));
                plotData.points = updatedPoints;
                console.log('‚úÖ Updated plotsData for', plotId, 'with', updatedPoints.length, 'points');
                console.log('   Points data:', JSON.stringify(updatedPoints, null, 2));
                
                // CRITICAL: Verify counts match
                if (updatedPoints.length !== reorderedCircles.length) {
                    console.error('‚ùå ERROR: Mismatch! plotPoints has', reorderedCircles.length, 'circles but plotsData has', updatedPoints.length, 'points!');
                }
            } else {
                console.error('‚ùå ERROR: Could not find plot', plotId, 'in plotsData!');
                console.log('Available plots in plotsData:', plotsData.map(p => p.id));
            }
            
            // Update polygon if in lines mode
            if (mode === 'lines') {
                updatePolygon(plotId);
            }
            
            // Reset selected existing circles to their original color (red)
            selectedCircles.forEach(circle => {
                circle.set({
                    fill: '#FF0000', // Red color
                    stroke: '#FFFFFF',
                    strokeWidth: 2
                });
                circle.setCoords();
            });
            
            // Clear create mode state but keep create mode enabled for continuous creation
            newPlotPoints = [];
            selectedExistingCircles = [];
            // Don't disable createMode - keep it enabled so user can continue creating
            
            // Ensure create mode handlers are still active
            canvas.defaultCursor = 'crosshair';
            canvas.hoverCursor = 'crosshair';
            canvas.selection = false;
            
            canvas.renderAll();
            
            console.log('Modified plot', plotId, 'by adding', newPoints.length, 'new point(s). State cleared, ready for new plot creation.');
        }
        
        function createNewPlot() {
            // Combine selected existing circles with newly created points
            const allPoints = [...selectedExistingCircles, ...newPlotPoints];
            
            // CRITICAL: Check if all selected existing circles belong to the same plot
            // If so, modify that existing plot instead of creating a new one
            // NO MINIMUM POINT REQUIREMENT when editing existing plots
            if (selectedExistingCircles.length > 0 && newPlotPoints.length > 0) {
                // Get unique plot IDs from selected circles
                const selectedPlotIds = new Set(selectedExistingCircles.map(c => c.plotId).filter(id => id && id !== 'new_plot'));
                
                // If all selected circles belong to the same existing plot, modify that plot
                if (selectedPlotIds.size === 1) {
                    const plotIdToModify = Array.from(selectedPlotIds)[0];
                    console.log('Modifying existing plot:', plotIdToModify, 'by adding', newPlotPoints.length, 'new point(s)');
                    modifyExistingPlot(plotIdToModify, selectedExistingCircles, newPlotPoints);
                    return;
                }
            }
            
            // Only check minimum points when creating a NEW plot (no selectedExistingCircles)
            // When editing existing plots, any number of points is allowed
            if (selectedExistingCircles.length === 0) {
                // Creating a NEW plot - need at least 3 points
                if (allPoints.length < 3) {
                    alert('Please create at least 3 points to form a new plot.');
                    return;
                }
            }
            // If selectedExistingCircles.length > 0 but not all from same plot, continue with creation
            // This handles the case where user selects points from different plots
            
            // Use the same scale/offset as existing plots (stored in circles)
            // This ensures consistency - new plots use the same coordinate system as existing ones
            let scale = 1;
            let offsetX = 0;
            let offsetY = 0;
            
            // Get scale/offset from existing circles if available
            const allExistingCircles = Object.values(plotPoints).flat();
            if (allExistingCircles.length > 0) {
                // Use the stored scale/offset from existing circles (consistent across all)
                scale = allExistingCircles[0].scale || 1;
                offsetX = allExistingCircles[0].offsetX || 0;
                offsetY = allExistingCircles[0].offsetY || 0;
            } else {
                // Fallback to background image if no existing circles
                const bgImg = canvas.backgroundImage;
                if (bgImg) {
                    scale = bgImg.scaleX || 1;
                    offsetX = bgImg.left || 0;
                    offsetY = bgImg.top || 0;
                }
            }
            
            // Order points properly (clockwise or counter-clockwise) to avoid X-shaped polygons
            // Combine both selected existing circles and new points
            const points = allPoints.map(circle => {
                // For all circles (existing and new), use their stored original coordinates
                // New circles should have originalX/originalY set when created
                let originalX, originalY;
                if (circle.originalX !== undefined && circle.originalY !== undefined) {
                    // Use stored original coordinates (most accurate)
                    originalX = circle.originalX;
                    originalY = circle.originalY;
                } else {
                    // Fallback: convert from canvas coordinates to original using stored scale/offset
                    originalX = Math.round((circle.left - offsetX) / scale);
                    originalY = Math.round((circle.top - offsetY) / scale);
                }
                return { 
                    x: originalX, 
                    y: originalY,
                    canvasX: circle.left,
                    canvasY: circle.top,
                    isExisting: selectedExistingCircles.includes(circle) // Track if it's an existing circle
                };
            });
            
            // Sort points in clockwise order around their centroid
            const centerX = points.reduce((sum, p) => sum + p.canvasX, 0) / points.length;
            const centerY = points.reduce((sum, p) => sum + p.canvasY, 0) / points.length;
            
            points.sort((a, b) => {
                const angleA = Math.atan2(a.canvasY - centerY, a.canvasX - centerX);
                const angleB = Math.atan2(b.canvasY - centerY, b.canvasX - centerX);
                return angleA - angleB;
            });
            
            // Remove canvas coordinates from final points
            const orderedPoints = points.map(p => ({ x: p.x, y: p.y }));
            
            // Store pending plot data (will be finalized after number assignment)
            // Include both selected existing circles and newly created points
            pendingPlotData = {
                points: orderedPoints,
                canvasPoints: allPoints, // All points (existing + new)
                selectedExistingCircles: selectedExistingCircles, // Track which are existing
                newPlotPoints: newPlotPoints, // Track which are newly created
                reorderedCircles: null // Will be set after reordering
            };
            
            // Find common points with existing plots for smart merging
            // Note: Selected existing circles are already common points, but they don't need merging
            // since they're already existing points that will be shared between plots
            const existingPlots = plotsData.filter(p => p.id && plotPoints[p.id]);
            const commonPoints = findCommonPoints(newPlotPoints, existingPlots);
            
            // Note: We don't add selected existing circles to commonPoints because:
            // 1. They're already existing points (not new points that need merging)
            // 2. They'll be included in the new plot as-is
            // 3. mergeCommonPoints only handles new points that need to be snapped to existing ones
            
            // Show number input dialog
            showNumberDialog(commonPoints);
        }
        
        function showNumberDialog(commonPoints) {
            const overlay = document.getElementById('number-dialog-overlay');
            const input = document.getElementById('plot-number-input');
            const maxPlotNum = Math.max(...plotsData.map(p => p.plot_number || 0), 0);
            
            // Set default value to max + 1, but allow user to change
            input.value = maxPlotNum + 1;
            input.min = 1;
            
            // Update dialog message if common points were found or existing circles selected
            const message = document.getElementById('number-dialog-message');
            const existingCount = selectedExistingCircles.length;
            const newCount = newPlotPoints.length;
            
            if (existingCount > 0) {
                message.innerHTML = `Enter the plot number. This plot will share <strong>${existingCount} point(s)</strong> with existing plot(s) and has <strong>${newCount} new point(s)</strong>. Other plots will be automatically renumbered.`;
                message.style.color = '#4CAF50';
            } else if (commonPoints.length > 0) {
                message.innerHTML = `Enter the plot number. <strong>${commonPoints.length} common point(s)</strong> will be automatically merged with adjacent plots. Other plots will be renumbered.`;
                message.style.color = '#4CAF50';
            } else {
                message.innerHTML = 'Enter the plot number. Other plots will be automatically renumbered.';
                message.style.color = '#666';
            }
            
            // Show dialog
            overlay.style.display = 'block';
            input.focus();
            input.select();
            
            // Handle confirm
            const confirmBtn = document.getElementById('confirm-number-btn');
            const cancelBtn = document.getElementById('cancel-number-btn');
            
            const handleConfirm = () => {
                const assignedNumber = parseInt(input.value);
                if (isNaN(assignedNumber) || assignedNumber < 1) {
                    alert('Please enter a valid plot number (1 or greater).');
                    return;
                }
                
                overlay.style.display = 'none';
                finalizePlotCreation(assignedNumber, commonPoints);
            };
            
            const handleCancel = () => {
                overlay.style.display = 'none';
                // Cancel plot creation - only remove newly created points
                // Don't remove selected existing circles (they belong to other plots)
                if (pendingPlotData && pendingPlotData.newPlotPoints) {
                    pendingPlotData.newPlotPoints.forEach(point => canvas.remove(point));
                } else {
                    // Fallback: remove all canvas points if structure is different
                    pendingPlotData.canvasPoints.forEach(point => {
                        // Only remove if it's a newly created point, not an existing one
                        if (point.plotId === 'new_plot' || !selectedExistingCircles.includes(point)) {
                            canvas.remove(point);
                        }
                    });
                }
                
                // Reset selected existing circles to their original color
                selectedExistingCircles.forEach(circle => {
                    circle.set({
                        fill: '#FF0000', // Red color
                        stroke: '#FFFFFF',
                        strokeWidth: 2
                    });
                    circle.setCoords();
                });
                
                newPlotPoints = [];
                selectedExistingCircles = [];
                pendingPlotData = null;
                enableCreateMode(); // Disable create mode
                canvas.renderAll();
            };
            
            // Remove old listeners and add new ones
            const newConfirmBtn = confirmBtn.cloneNode(true);
            const newCancelBtn = cancelBtn.cloneNode(true);
            confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
            cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
            
            newConfirmBtn.onclick = handleConfirm;
            newCancelBtn.onclick = handleCancel;
            
            // Allow Enter key to confirm
            input.onkeydown = (e) => {
                if (e.key === 'Enter') {
                    handleConfirm();
                } else if (e.key === 'Escape') {
                    handleCancel();
                }
            };
            
            // Close dialog when clicking on overlay (but not on dialog itself)
            overlay.onclick = (e) => {
                if (e.target === overlay) {
                    handleCancel();
                }
            };
        }
        
        function finalizePlotCreation(assignedNumber, commonPoints) {
            if (!pendingPlotData) return;
            
            // Merge common points (snap new points to existing ones)
            if (commonPoints.length > 0) {
                mergeCommonPoints(pendingPlotData.canvasPoints, commonPoints);
                
                // Recalculate points after merging
                // Use the same scale/offset as existing plots (stored in circles)
                let scale = 1;
                let offsetX = 0;
                let offsetY = 0;
                
                // Get scale/offset from existing circles if available
                const allExistingCircles = Object.values(plotPoints).flat();
                if (allExistingCircles.length > 0) {
                    scale = allExistingCircles[0].scale || 1;
                    offsetX = allExistingCircles[0].offsetX || 0;
                    offsetY = allExistingCircles[0].offsetY || 0;
                } else {
                    // Fallback to background image if no existing circles
                    const bgImg = canvas.backgroundImage;
                    if (bgImg) {
                        scale = bgImg.scaleX || 1;
                        offsetX = bgImg.left || 0;
                        offsetY = bgImg.top || 0;
                    }
                }
                
                pendingPlotData.points = pendingPlotData.canvasPoints.map(circle => {
                    // For all circles (existing and new), use their stored original coordinates
                    // CRITICAL: Use each circle's own scale/offset if available
                    let originalX, originalY;
                    if (circle.originalX !== undefined && circle.originalY !== undefined) {
                        // Use stored original coordinates (most accurate)
                        originalX = circle.originalX;
                        originalY = circle.originalY;
                    } else {
                        // Fallback: convert from canvas coordinates to original
                        // Use circle's own scale/offset if available, otherwise use global
                        const circleScale = circle.scale || scale;
                        const circleOffsetX = circle.offsetX !== undefined ? circle.offsetX : offsetX;
                        const circleOffsetY = circle.offsetY !== undefined ? circle.offsetY : offsetY;
                        originalX = Math.round((circle.left - circleOffsetX) / circleScale);
                        originalY = Math.round((circle.top - circleOffsetY) / circleScale);
                        // Store for future use
                        circle.originalX = originalX;
                        circle.originalY = originalY;
                    }
                    return { x: originalX, y: originalY };
                });
            }
            
            // Auto-renumber existing plots (this happens before adding the new plot)
            autoRenumberPlots(assignedNumber);
            
            // Create new plot data with assigned number
            // CRITICAL: Use the points calculated from pendingPlotData (with original coordinates)
            const newPlot = {
                id: 'Plot ' + assignedNumber,
                plot_number: assignedNumber,
                points: pendingPlotData.points  // These are already in original coordinate space
            };
            
            console.log('Creating new plot:', newPlot.id, 'with', newPlot.points.length, 'points:', newPlot.points);
            
            // Add new plot to plotsData and sort
            plotsData.push(newPlot);
            plotsData.sort((a, b) => (a.plot_number || 0) - (b.plot_number || 0));
            
            console.log('plotsData now has', plotsData.length, 'plots. New plot added:', newPlot.id);
            
            // Reorder circles to match the sorted order (using canvas coordinates)
            // Use the same scale/offset as existing plots (stored in circles)
            let scale = 1;
            let offsetX = 0;
            let offsetY = 0;
            
            // Get scale/offset from existing circles if available
            const allExistingCircles = Object.values(plotPoints).flat();
            if (allExistingCircles.length > 0) {
                scale = allExistingCircles[0].scale || 1;
                offsetX = allExistingCircles[0].offsetX || 0;
                offsetY = allExistingCircles[0].offsetY || 0;
            } else {
                // Fallback to background image if no existing circles
                const bgImg = canvas.backgroundImage;
                if (bgImg) {
                    scale = bgImg.scaleX || 1;
                    offsetX = bgImg.left || 0;
                    offsetY = bgImg.top || 0;
                }
            }
            
            // Create points with canvas coordinates for sorting
            const pointsWithCanvas = pendingPlotData.canvasPoints.map(circle => {
                // For all circles (existing and new), use their stored original coordinates
                // CRITICAL: Use each circle's own scale/offset if available
                let originalX, originalY;
                if (circle.originalX !== undefined && circle.originalY !== undefined) {
                    // Use stored original coordinates (most accurate)
                    originalX = circle.originalX;
                    originalY = circle.originalY;
                } else {
                    // Fallback: convert from canvas coordinates to original
                    // Use circle's own scale/offset if available, otherwise use global
                    const circleScale = circle.scale || scale;
                    const circleOffsetX = circle.offsetX !== undefined ? circle.offsetX : offsetX;
                    const circleOffsetY = circle.offsetY !== undefined ? circle.offsetY : offsetY;
                    originalX = Math.round((circle.left - circleOffsetX) / circleScale);
                    originalY = Math.round((circle.top - circleOffsetY) / circleScale);
                    // Store for future use
                    circle.originalX = originalX;
                    circle.originalY = originalY;
                }
                return {
                    x: originalX,
                    y: originalY,
                    canvasX: circle.left,
                    canvasY: circle.top,
                    circle: circle
                };
            });
            
            // Sort points in clockwise order around their centroid
            const centerX = pointsWithCanvas.reduce((sum, p) => sum + p.canvasX, 0) / pointsWithCanvas.length;
            const centerY = pointsWithCanvas.reduce((sum, p) => sum + p.canvasY, 0) / pointsWithCanvas.length;
            
            pointsWithCanvas.sort((a, b) => {
                const angleA = Math.atan2(a.canvasY - centerY, a.canvasX - centerX);
                const angleB = Math.atan2(b.canvasY - centerY, b.canvasX - centerX);
                return angleA - angleB;
            });
            
            const reorderedCircles = pointsWithCanvas.map(p => p.circle);
            pendingPlotData.reorderedCircles = reorderedCircles;
            
            // Update circles to be red (normal color) and assign plot ID
            // But keep selected existing circles with their original plot IDs (they're shared)
            reorderedCircles.forEach((circle, idx) => {
                const isExistingCircle = pendingPlotData.selectedExistingCircles && 
                                       pendingPlotData.selectedExistingCircles.includes(circle);
                
                if (!isExistingCircle) {
                    // NEWLY CREATED circle - assign to new plot and set all required properties
                    // CRITICAL: Only modify NEW circles, never touch existing ones
                    
                    // Get the circle's current scale/offset if it exists (from when it was created)
                    const circleScale = circle.scale || scale;
                    const circleOffsetX = circle.offsetX !== undefined ? circle.offsetX : offsetX;
                    const circleOffsetY = circle.offsetY !== undefined ? circle.offsetY : offsetY;
                    
                    // Ensure originalX and originalY are set (recalculate if missing)
                    if (circle.originalX === undefined || circle.originalY === undefined) {
                        circle.originalX = Math.round((circle.left - circleOffsetX) / circleScale);
                        circle.originalY = Math.round((circle.top - circleOffsetY) / circleScale);
                    }
                    
                    // Assign to new plot and set properties
                    circle.set({
                        fill: '#FF0000',
                        plotId: newPlot.id,
                        pointIndex: idx
                    });
                    
                    // Store properties directly on circle object (critical for saving)
                    circle.scale = circleScale;
                    circle.offsetX = circleOffsetX;
                    circle.offsetY = circleOffsetY;
                } else {
                    // EXISTING circle - DO NOT MODIFY any properties, just reset color
                    // Preserve all existing properties (scale, offsetX, offsetY, originalX, originalY)
                    // This prevents existing plots from moving
                    circle.set({
                        fill: '#FF0000', // Reset to red
                        stroke: '#FFFFFF',
                        strokeWidth: 2
                    });
                    // DO NOT touch scale, offsetX, offsetY, originalX, originalY - they're already correct
                }
                
                // Track if circle was moved (to distinguish click from drag)
                let circleMoved = false;
                let circleMouseDownTime = 0;
                
                // Make circle easily clickable for selection (same as existing plots)
                circle.set({
                    evented: true,
                    selectable: true,  // Allow selection for dragging
                    hoverCursor: 'pointer',
                    perPixelTargetFind: true  // Better click detection
                });
                
                // Add comprehensive click handler (same as existing plots)
                circle.on('mousedown', function(e) {
                    circleMoved = false;
                    circleMouseDownTime = Date.now();
                    
                    // Handle Ctrl+Click for multi-dot selection (for pixel move and merge)
                    if (e.e.ctrlKey || e.e.metaKey) {
                        e.e.stopPropagation();
                        e.e.stopImmediatePropagation();
                        
                        // Add to move selection
                        const isAlreadySelectedMove = selectedDotsForMove.includes(this);
                        
                        if (isAlreadySelectedMove) {
                            // Deselect from move
                            const index = selectedDotsForMove.indexOf(this);
                            selectedDotsForMove.splice(index, 1);
                        } else {
                            // Select for move
                            selectedDotsForMove.push(this);
                        }
                        
                        // Also handle merge selection (max 2 points)
                        const isAlreadySelectedMerge = selectedPointsForMerge.includes(this);
                        
                        if (isAlreadySelectedMerge) {
                            // Deselect from merge
                            const index = selectedPointsForMerge.indexOf(this);
                            selectedPointsForMerge.splice(index, 1);
                            this.set({ fill: '#FF0000', stroke: '#FFFFFF', strokeWidth: 2 });
                        } else {
                            // Select for merge (max 2 points)
                            if (selectedPointsForMerge.length < 2) {
                                selectedPointsForMerge.push(this);
                                this.set({ fill: '#00FF00', stroke: '#000000', strokeWidth: 3 });
                            } else {
                                // Already have 2 selected, replace first
                                const firstPoint = selectedPointsForMerge[0];
                                firstPoint.set({ fill: '#FF0000', stroke: '#FFFFFF', strokeWidth: 2 });
                                selectedPointsForMerge.shift();
                                selectedPointsForMerge.push(this);
                                this.set({ fill: '#00FF00', stroke: '#000000', strokeWidth: 3 });
                            }
                        }
                        
                        // Update visual for move selection
                        if (isAlreadySelectedMove) {
                            this.set({ stroke: '#FFFFFF', strokeWidth: 2 });
                        } else {
                            this.set({ stroke: '#4CAF50', strokeWidth: 4 }); // Green highlight for move
                        }
                        
                        this.setCoords();
                        canvas.renderAll();
                        updateMoveButtonCounter();
                        updateMergeButtonText();
                        return false;
                    } else if (createMode) {
                        // In create mode, handle circle selection for new plot
                        e.e.stopPropagation();
                        e.e.stopImmediatePropagation();
                        
                        // Check if already selected
                        const isAlreadySelected = selectedExistingCircles.includes(this);
                        
                        if (isAlreadySelected) {
                            // Deselect
                            const index = selectedExistingCircles.indexOf(this);
                            selectedExistingCircles.splice(index, 1);
                            this.set({
                                fill: '#FF0000',
                                stroke: '#FFFFFF',
                                strokeWidth: 2
                            });
                            this.setCoords();
                            console.log('Deselected existing circle. Selected:', selectedExistingCircles.length);
                        } else {
                            // Select (max 4)
                            if (selectedExistingCircles.length < 4) {
                                selectedExistingCircles.push(this);
                                this.set({
                                    fill: '#00FF00', // Green for selected
                                    stroke: '#FFFFFF',
                                    strokeWidth: 3
                                });
                                this.setCoords();
                                console.log('Selected existing circle. Selected:', selectedExistingCircles.length, '/ 4');
                            } else {
                                alert('You can select up to 4 existing dots. Click on a selected dot to deselect it, or create additional points.');
                                return false;
                            }
                        }
                        
                        updateCreateButtonText();
                        canvas.renderAll();
                        return false;
                    } else if (!createMode && !mergeMode) {
                        // Allow normal Fabric.js selection and dragging for dots
                        // Don't stop propagation - let Fabric.js handle selection and dragging
                        // Plot selection will be handled in mouseup if it was just a click (not drag)
                    }
                });
                
                // Handle mouseup for plot selection (only if not dragged) - same as existing plots
                circle.on('mouseup', function(e) {
                    if (mergeMode) {
                        e.e.stopPropagation();
                        e.e.stopImmediatePropagation();
                        return false;
                    } else if (!createMode && !mergeMode && !circleMoved) {
                        // Only select if it was a click (not a drag)
                        const clickDuration = Date.now() - circleMouseDownTime;
                        if (clickDuration < 300) { // Quick click, not a drag
                            e.e.stopPropagation();
                            e.e.stopImmediatePropagation();
                            console.log('Circle clicked (not dragged), selecting plot:', this.plotId);
                            if (this.plotId) {
                                selectPlotForDelete(this.plotId);
                            } else {
                                console.warn('Circle has no plotId:', this);
                            }
                            return false;
                        }
                    }
                });
                
                // Make circles draggable - same as existing plots
                circle.on('moving', function(e) {
                    circleMoved = true; // Track that circle was moved
                    
                    // Update original coordinates when circle is moved
                    const storedScale = this.scale || 1;
                    const storedOffsetX = this.offsetX || 0;
                    const storedOffsetY = this.offsetY || 0;
                    
                    // Calculate original coordinates using the stored scale/offset
                    this.originalX = Math.round((this.left - storedOffsetX) / storedScale);
                    this.originalY = Math.round((this.top - storedOffsetY) / storedScale);
                    
                    // CRITICAL: Update selection box coordinates to prevent offset
                    this.setCoords();
                    
                    // CRITICAL: Update polygon in real-time if in lines mode
                    if (mode === 'lines') {
                        updatePolygon(this.plotId);
                    }
                    canvas.renderAll();
                });
                
                // Handle modified event - same as existing plots
                circle.on('modified', function() {
                    if (mode === 'lines') {
                        updatePolygon(this.plotId);
                    }
                });
            });
            
            // Store reordered circles in plotPoints
            // CRITICAL: This links the plot ID to its circles for saving
            plotPoints[newPlot.id] = reorderedCircles;
            console.log('Stored', reorderedCircles.length, 'circles in plotPoints[' + newPlot.id + ']');
            
            // If in lines mode, create polygon
            if (mode === 'lines') {
                // Use the reordered circles for polygon points
                const circlesForPolygon = reorderedCircles;
                const absolutePoints = circlesForPolygon.map(c => ({ x: c.left, y: c.top }));
                
                // Calculate bounding box to set polygon position
                const minX = Math.min(...absolutePoints.map(p => p.x));
                const minY = Math.min(...absolutePoints.map(p => p.y));
                
                // Convert to relative coordinates (relative to bounding box minimum)
                const relativePoints = absolutePoints.map(point => ({
                    x: point.x - minX,
                    y: point.y - minY
                }));
                
                const polygon = new fabric.Polygon(relativePoints, {
                    left: minX,
                    top: minY,
                    fill: 'transparent',
                    stroke: '#FF0000',
                    strokeWidth: 2,
                    opacity: 0.7,
                    selectable: false, // Not selectable - only dots are draggable
                    evented: true,
                    plotId: newPlot.id,
                    plotNumber: assignedNumber,
                    hasControls: false,
                    hasBorders: false,
                    objectCaching: false,  // Disable caching for accurate coordinate handling
                    noScaleCache: true,    // Disable scale cache
                    statefullCache: false  // Disable stateful cache
                });
                
                // Store original position for reference
                polygon.originalLeft = minX;
                polygon.originalTop = minY;
                
                // Add click handler for plot selection and point creation (same as existing plots)
                polygon.on('mousedown', function(e) {
                    // In create mode, allow clicking on polygon to add points on the line
                    if (createMode) {
                        e.e.stopPropagation();
                        e.e.stopImmediatePropagation();
                        
                        // Convert mouse coordinates to world coordinates
                        const worldPoint = mouseToWorldCoordinates(canvas, e.e);
                        
                        // Find closest point on polygon line segment
                        const closest = findClosestPointOnPolygon(worldPoint, polygon);
                        
                        if (closest && closest.point) {
                            // Create point at projected location on the line
                            const projectedPoint = closest.point;
                            
                            // Get scale/offset for coordinate conversion
                            const allExistingCircles = Object.values(plotPoints).flat();
                            let scale = 1;
                            let offsetX = 0;
                            let offsetY = 0;
                            
                            if (allExistingCircles.length > 0) {
                                scale = allExistingCircles[0].scale || 1;
                                offsetX = allExistingCircles[0].offsetX || 0;
                                offsetY = allExistingCircles[0].offsetY || 0;
                            } else {
                                const bgImg = window.canvasBgImg || canvas.backgroundImage;
                                if (bgImg) {
                                    scale = bgImg.originalScaleX || bgImg.scaleX || 1;
                                    offsetX = bgImg.originalLeft || bgImg.left || 0;
                                    offsetY = bgImg.originalTop || bgImg.top || 0;
                                }
                            }
                            
                            // Calculate original coordinates
                            const originalX = Math.round((projectedPoint.x - offsetX) / scale);
                            const originalY = Math.round((projectedPoint.y - offsetY) / scale);
                            
                            // Check if too close to existing points from other plots
                            const minDistance = 15;
                            let tooClose = false;
                            
                            Object.values(plotPoints).flat().forEach(existingCircle => {
                                if (existingCircle.plotId !== 'new_plot' && !selectedExistingCircles.includes(existingCircle)) {
                                    const dx = projectedPoint.x - existingCircle.left;
                                    const dy = projectedPoint.y - existingCircle.top;
                                    const distance = Math.sqrt(dx * dx + dy * dy);
                                    if (distance < minDistance) {
                                        tooClose = true;
                                    }
                                }
                            });
                            
                            if (!tooClose) {
                                // Create point at projected location
                                const circle = new fabric.Circle({
                                    left: projectedPoint.x,
                                    top: projectedPoint.y,
                                    radius: 4,
                                    fill: '#0000FF',
                                    stroke: '#FFFFFF',
                                    strokeWidth: 2,
                                    originX: 'center',
                                    originY: 'center',
                                    selectable: true,
                                    hasControls: false,
                                    hasBorders: true,
                                    borderColor: '#0066CC',
                                    cornerColor: '#0066CC',
                                    cornerSize: 8,
                                    plotId: 'new_plot',
                                    pointIndex: newPlotPoints.length,
                                    scale: scale,
                                    offsetX: offsetX,
                                    offsetY: offsetY,
                                    originalX: originalX,
                                    originalY: originalY,
                                    evented: true,
                                    hoverCursor: 'move',
                                    moveCursor: 'move',
                                    objectCaching: false,
                                    noScaleCache: true,
                                    statefullCache: false
                                });
                                
                                circle.on('moving', function(e) {
                                    const storedScale = this.scale || 1;
                                    const storedOffsetX = this.offsetX || 0;
                                    const storedOffsetY = this.offsetY || 0;
                                    
                                    this.originalX = Math.round((this.left - storedOffsetX) / storedScale);
                                    this.originalY = Math.round((this.top - storedOffsetY) / storedScale);
                                    
                                    this.setCoords();
                                    canvas.renderAll();
                                });
                                
                                newPlotPoints.push(circle);
                                canvas.add(circle);
                                canvas.bringToFront(circle);
                                canvas.renderAll();
                                
                                updateCreateButtonText();
                            }
                        }
                        
                        return false;
                    }
                    
                    // In delete mode, select plot for deletion
                    if (!createMode && !mergeMode) {
                        e.e.stopPropagation();
                        e.e.stopImmediatePropagation();
                        console.log('Polygon clicked, selecting plot:', newPlot.id);
                        selectPlotForDelete(newPlot.id);
                        return false;
                    }
                });
                
                // Also handle mouseup for better click detection (same as existing plots)
                polygon.on('mouseup', function(e) {
                    if (!createMode && !mergeMode) {
                        e.e.stopPropagation();
                        e.e.stopImmediatePropagation();
                        console.log('Polygon mouseup, selecting plot:', newPlot.id);
                        selectPlotForDelete(newPlot.id);
                        return false;
                    }
                });
                
                // Note: Circle event handlers (moving, modified, mousedown, mouseup) are already
                // added above for all circles in reorderedCircles, so no need to add them again here
                
                plotObjects.push(polygon);
                canvas.add(polygon);
                
                // Ensure proper z-order: background < polygon < circles < text
                if (canvas.backgroundImage) {
                    canvas.backgroundImage.moveTo(0); // Background at bottom
                }
                
                // Add plot number label
                // Use absolutePoints to calculate center (these are the actual canvas coordinates)
                const centerX = absolutePoints.reduce((sum, p) => sum + p.x, 0) / absolutePoints.length;
                const centerY = absolutePoints.reduce((sum, p) => sum + p.y, 0) / absolutePoints.length;
                const text = new fabric.Text(String(assignedNumber), {
                    left: centerX,
                    top: centerY,
                    fontSize: 14,
                    fill: '#000000',
                    originX: 'center',
                    originY: 'center',
                    selectable: false,
                    evented: false,
                    plotId: newPlot.id,
                    visible: true,  // Ensure text is visible immediately
                    objectCaching: false,  // Disable caching for accurate coordinate handling
                    noScaleCache: true,   // Disable scale cache
                    statefullCache: false // Disable stateful cache
                });
                
                // Store original position for zoom functionality
                text.originalLeft = centerX;
                text.originalTop = centerY;
                canvas.add(text);
                
                // Bring circles and text to front (above polygon)
                circlesForPolygon.forEach(circle => canvas.bringToFront(circle));
                canvas.bringToFront(text);
                
                // Force immediate render to show plot number
                canvas.renderAll();
            } else {
                // In points mode, also add plot number label
                // Calculate center from circle positions
                const centerX = reorderedCircles.reduce((sum, c) => sum + c.left, 0) / reorderedCircles.length;
                const centerY = reorderedCircles.reduce((sum, c) => sum + c.top, 0) / reorderedCircles.length;
                const text = new fabric.Text(String(assignedNumber), {
                    left: centerX,
                    top: centerY,
                    fontSize: 14,
                    fill: '#000000',
                    originX: 'center',
                    originY: 'center',
                    selectable: false,
                    evented: false,
                    plotId: newPlot.id,
                    visible: true,  // Ensure text is visible immediately
                    objectCaching: false,  // Disable caching for accurate coordinate handling
                    noScaleCache: true,   // Disable scale cache
                    statefullCache: false // Disable stateful cache
                });
                
                // Store original position for zoom functionality
                text.originalLeft = centerX;
                text.originalTop = centerY;
                canvas.add(text);
                
                // Ensure circles and text are on top
                reorderedCircles.forEach(circle => canvas.bringToFront(circle));
                canvas.bringToFront(text);
                
                // Force immediate render to show plot number
                canvas.renderAll();
            }
            
            // Reset selected existing circles to their original color
            if (pendingPlotData && pendingPlotData.selectedExistingCircles) {
                pendingPlotData.selectedExistingCircles.forEach(circle => {
                    circle.set({
                        fill: '#FF0000', // Red color
                        stroke: '#FFFFFF',
                        strokeWidth: 2
                    });
                    circle.setCoords();
                });
            }
            
            newPlotPoints = [];
            selectedExistingCircles = [];
            pendingPlotData = null;
            
            // CRITICAL: Explicitly disable create mode (don't toggle, just disable)
            if (createMode) {
                createMode = false;
                const createBtn = document.getElementById('create-btn');
                const deleteBtn = document.getElementById('delete-btn');
                if (createBtn) {
                    createBtn.textContent = 'Create Plot';
                    createBtn.style.backgroundColor = '#4CAF50';
                }
                canvas.defaultCursor = 'default';
                canvas.hoverCursor = 'default';
                canvas.off('mouse:down', handleCreatePlotClick);
                canvas.selection = true;
                if (deleteBtn) deleteBtn.style.opacity = '1';
            }
            
            // Force immediate render to show plot number
            canvas.renderAll();
            
            console.log('New plot created with number:', assignedNumber, newPlot);
            
            // Show success message if points were merged
            if (commonPoints.length > 0) {
                console.log(`‚úÖ Automatically merged ${commonPoints.length} common point(s) with adjacent plots`);
            }
        }
        
        
        function enableDeleteMode() {
            // This function is kept for backward compatibility but not used in the new flow
            // Plots can now be selected at any time without entering delete mode
            deleteMode = !deleteMode;
            createMode = false;
            mergeMode = false;
            selectedPointsForMerge = [];
            
            // Don't clear selection when toggling delete mode
            // selectedPlotForDelete = null;
            
            // Hide confirmation dialog if it's open
            hideDeleteConfirmation();
            
            const deleteBtn = document.getElementById('delete-btn');
            const createBtn = document.getElementById('create-btn');
            const mergeBtn = document.getElementById('merge-btn');
            
            if (deleteMode) {
                deleteBtn.textContent = 'Delete';
                deleteBtn.style.backgroundColor = '#f44336';
                canvas.defaultCursor = 'pointer';
                canvas.hoverCursor = 'pointer';
                if (createBtn) createBtn.style.opacity = '0.5';
                if (mergeBtn) mergeBtn.style.opacity = '0.5';
                
                // Highlight all plots for selection
                if (mode === 'lines') {
                    plotObjects.forEach(polygon => {
                        polygon.set({ 
                            stroke: '#FF0000',
                            strokeWidth: 3,
                            opacity: 0.9
                        });
                    });
                } else {
                    // In points mode, highlight all circles
                    Object.values(plotPoints).flat().forEach(circle => {
                        circle.set({ 
                            fill: '#FF0000',
                            stroke: '#FFFFFF',
                            strokeWidth: 3
                        });
                    });
                }
                canvas.renderAll();
            } else {
                deleteBtn.textContent = 'Delete Plot';
                deleteBtn.style.backgroundColor = '#f44336';
                canvas.defaultCursor = 'default';
                canvas.hoverCursor = 'default';
                if (createBtn) createBtn.style.opacity = '1';
                if (mergeBtn) mergeBtn.style.opacity = '1';
                
                // Reset plot highlighting (but keep selection if one exists)
                if (mode === 'lines') {
                    plotObjects.forEach(polygon => {
                        if (polygon.plotId === selectedPlotForDelete) {
                            // Keep blue highlight for selected plot
                            polygon.set({ 
                                stroke: '#0066FF',  // Blue for selected
                                strokeWidth: 4,
                                opacity: 1
                            });
                        } else {
                            // Red for unselected plots
                            polygon.set({ 
                                stroke: '#FF0000',  // Red for unselected
                                strokeWidth: 2,
                                opacity: 0.7
                            });
                        }
                    });
                } else {
                    Object.values(plotPoints).flat().forEach(circle => {
                        if (circle.plotId === selectedPlotForDelete) {
                            // Keep blue highlight for selected plot
                            circle.set({ 
                                fill: '#0066FF',  // Blue for selected
                                stroke: '#FFFFFF',
                                strokeWidth: 4
                            });
                        } else {
                            // Red for unselected plots
                            circle.set({ 
                                fill: '#FF0000',  // Red for unselected
                                stroke: '#FFFFFF',
                                strokeWidth: 2
                            });
                        }
                    });
                }
                canvas.renderAll();
            }
        }
        
        function ensureProperZOrder() {
            // Ensure background image is always at the very back
            canvas.getObjects().forEach(obj => {
                if (obj.isBackgroundImage) {
                    canvas.sendToBack(obj);
                }
            });
            
            // Ensure all polygons are above background
            plotObjects.forEach(polygon => {
                canvas.bringToFront(polygon);
            });
            
            // Ensure all circles are above polygons
            Object.values(plotPoints).flat().forEach(circle => {
                canvas.bringToFront(circle);
            });
            
            // Ensure all text is above everything
            canvas.getObjects().forEach(obj => {
                if (obj.type === 'text' && obj.plotId) {
                    canvas.bringToFront(obj);
                }
            });
        }
        
        function clearPlotSelection() {
            // Clear plot selection and reset all plots to default appearance
            if (!selectedPlotForDelete) return;
            
            const plotId = selectedPlotForDelete;
            selectedPlotForDelete = null;
            
            // Reset all plots to default appearance (red)
            if (mode === 'lines') {
                plotObjects.forEach(polygon => {
                    polygon.set({
                        stroke: '#FF0000',
                        strokeWidth: 2,
                        opacity: 0.7
                    });
                    polygon.setCoords();
                    polygon.dirty = true;
                });
            } else {
                // Points mode - reset all circles to red
                Object.values(plotPoints).flat().forEach(circle => {
                    circle.set({
                        fill: '#FF0000',
                        stroke: '#FFFFFF',
                        strokeWidth: 2
                    });
                    circle.setCoords();
                    circle.dirty = true;
                });
            }
            
            canvas.renderAll();
            console.log('Plot selection cleared');
        }
        
        function selectPlotForDelete(plotId) {
            // Allow selection at any time (not just in delete mode)
            console.log('selectPlotForDelete called with plotId:', plotId, 'type:', typeof plotId);
            console.log('Current mode:', mode);
            console.log('Number of plotObjects:', plotObjects.length);
            console.log('Number of plotPoints:', Object.keys(plotPoints).length);
            
            selectedPlotForDelete = plotId;
            
            // Highlight selected plot with different color (blue for selected, red for others)
            if (mode === 'lines') {
                console.log('Updating polygons for lines mode');
                let foundMatch = false;
                
                // First, ensure background image is at the back
                if (canvas.backgroundImage) {
                    canvas.sendToBack(canvas.backgroundImage);
                }
                
                plotObjects.forEach((polygon, idx) => {
                    const polygonId = String(polygon.plotId || '');
                    const targetId = String(plotId || '');
                    const matches = polygonId === targetId;
                    console.log(`Polygon ${idx}: plotId="${polygonId}", target="${targetId}", matches=${matches}`);
                    
                    if (matches) {
                        foundMatch = true;
                        // Selected plot: Blue color with thicker border
                        console.log('‚úì MATCH FOUND! Setting polygon to BLUE (selected)');
                        // Update properties
                        polygon.set('stroke', '#0066FF');  // Blue color for selected
                        polygon.set('strokeWidth', 4);
                        polygon.set('opacity', 1);
                        // Force update and refresh
                        polygon.setCoords();
                        polygon.dirty = true;
                        
                        // CRITICAL: Bring selected polygon to the very front so it's visible
                        // First bring all its associated elements to front
                        if (plotPoints[plotId]) {
                            plotPoints[plotId].forEach(circle => canvas.bringToFront(circle));
                        }
                        canvas.getObjects().forEach(obj => {
                            if (obj.type === 'text' && obj.plotId === plotId) {
                                canvas.bringToFront(obj);
                            }
                        });
                        // Then bring the polygon itself to front (above other polygons)
                        canvas.bringToFront(polygon);
                        
                        console.log('Polygon updated. Current stroke:', polygon.stroke, 'strokeWidth:', polygon.strokeWidth);
                        console.log('Polygon brought to front, should be visible now');
                    } else {
                        // Other plots: Red color - ensure they're above background but below selected
                        polygon.set('stroke', '#FF0000');  // Red color for unselected
                        polygon.set('strokeWidth', 2);
                        polygon.set('opacity', 0.7);
                        polygon.setCoords();
                        polygon.dirty = true;
                        // Keep other polygons in their current position (above background)
                    }
                });
                
                if (!foundMatch) {
                    console.error('‚ùå NO MATCH FOUND! plotId mismatch.');
                    console.error('Target plotId:', plotId, 'Type:', typeof plotId);
                    console.error('Available plotIds:', plotObjects.map((p, i) => `${i}: "${p.plotId}" (type: ${typeof p.plotId})`));
                }
            } else {
                // In points mode, highlight circles of selected plot
                console.log('Updating circles for points mode');
                let foundMatch = false;
                
                Object.keys(plotPoints).forEach(id => {
                    // Use string comparison to handle type mismatches
                    const matches = String(id || '') === String(plotId || '');
                    console.log(`PlotPoints key="${id}", target="${plotId}", matches=${matches}`);
                    
                    plotPoints[id].forEach((circle, idx) => {
                        if (matches) {
                            foundMatch = true;
                            // Selected plot: Blue color with thicker border
                            console.log(`Setting circle ${idx} to BLUE (selected) for plot ${id}`);
                            circle.set({ 
                                fill: '#0066FF',  // Blue color for selected
                                stroke: '#FFFFFF',
                                strokeWidth: 4,
                                radius: circle.radius || 6  // Ensure radius is set
                            });
                            circle.setCoords();
                            circle.dirty = true;
                            
                            // Bring selected circles to front
                            canvas.bringToFront(circle);
                            
                            // Force immediate render
                            canvas.requestRenderAll();
                        } else {
                            // Other plots: Red color
                            circle.set({ 
                                fill: '#FF0000',  // Red color for unselected
                                stroke: '#FFFFFF',
                                strokeWidth: 2,
                                radius: circle.radius || 6  // Ensure radius is set
                            });
                            circle.setCoords();
                            circle.dirty = true;
                        }
                    });
                });
                
                if (!foundMatch) {
                    console.error('‚ùå NO MATCH FOUND in points mode! plotId mismatch.');
                    console.error('Target plotId:', plotId, 'Type:', typeof plotId);
                    console.error('Available plotIds:', Object.keys(plotPoints));
                    console.error('plotPoints contents:', Object.keys(plotPoints).map(k => ({ key: k, circles: plotPoints[k].length })));
                } else {
                    console.log('‚úÖ Match found and circles updated in points mode');
                }
            }
            
            // Force canvas to re-render multiple times to ensure update
            canvas.discardActiveObject();
            
            // CRITICAL: Ensure proper z-order (background at back, polygons/circles/text on top)
            ensureProperZOrder();
            
            // Force full render
            canvas.requestRenderAll();
            canvas.renderAll();
            
            // Force another render after a short delay to ensure visual update
            setTimeout(() => {
                // Re-ensure proper z-order
                ensureProperZOrder();
                canvas.requestRenderAll();
                canvas.renderAll();
                console.log('Plot selected for deletion:', plotId, '- Canvas re-rendered (delayed)');
            }, 50);
            
            console.log('Plot selected for deletion:', plotId, '- Canvas re-rendered (immediate)');
        }
        
        function renumberPlots() {
            // Create a mapping of old IDs to new IDs
            const idMapping = {};
            
            // Sort plots by their current plot_number to maintain order
            plotsData.sort((a, b) => (a.plot_number || 0) - (b.plot_number || 0));
            
            // Renumber all plots sequentially starting from 1
            plotsData.forEach((plot, index) => {
                const newPlotNum = index + 1;
                const oldPlotId = plot.id;
                const oldPlotNum = plot.plot_number;
                
                plot.plot_number = newPlotNum;
                plot.id = 'Plot ' + newPlotNum;
                
                // Store mapping for updating references
                idMapping[oldPlotId] = plot.id;
                
                // Update plot number text on canvas
                canvas.getObjects().forEach(obj => {
                    if (obj.plotId === oldPlotId) {
                        obj.set('plotId', plot.id);
                        if (obj.type === 'text') {
                            obj.set('text', String(newPlotNum));
                        }
                        if (obj.plotNumber !== undefined) {
                            obj.set('plotNumber', newPlotNum);
                        }
                    }
                });
            });
            
            // Update plotPoints keys to use new IDs
            const newPlotPoints = {};
            Object.keys(plotPoints).forEach(oldId => {
                if (idMapping[oldId]) {
                    newPlotPoints[idMapping[oldId]] = plotPoints[oldId];
                    // Update plotId in all circles
                    if (plotPoints[oldId]) {
                        plotPoints[oldId].forEach(circle => {
                            circle.set('plotId', idMapping[oldId]);
                        });
                    }
                }
            });
            Object.keys(plotPoints).forEach(key => {
                if (!newPlotPoints[key] && !idMapping[key]) {
                    delete plotPoints[key];
                }
            });
            Object.assign(plotPoints, newPlotPoints);
            
            // Update plotObjects (polygons) IDs
            plotObjects.forEach(polygon => {
                if (idMapping[polygon.plotId]) {
                    polygon.set('plotId', idMapping[polygon.plotId]);
                }
            });
            
            console.log('Plots renumbered:', plotsData.map(p => ({ id: p.id, num: p.plot_number })));
        }
        
        function showDeleteConfirmation(plotId) {
            if (!plotId) return;
            
            // Find plot info
            const plot = plotsData.find(p => p.id === plotId);
            const plotInfo = plot ? `Plot ${plot.plot_number || plotId}` : `Plot ${plotId}`;
            
            // Update dialog message
            const deletePlotInfo = document.getElementById('delete-plot-info');
            if (deletePlotInfo) {
                deletePlotInfo.textContent = plotInfo;
            }
            
            // Show dialog
            const deleteDialogOverlay = document.getElementById('delete-dialog-overlay');
            if (deleteDialogOverlay) {
                deleteDialogOverlay.style.display = 'block';
            }
        }
        
        function hideDeleteConfirmation() {
            const deleteDialogOverlay = document.getElementById('delete-dialog-overlay');
            if (deleteDialogOverlay) {
                deleteDialogOverlay.style.display = 'none';
            }
        }
        
        function deletePlot(plotId) {
            if (!plotId) return;
            
            console.log('üóëÔ∏è Deleting plot:', plotId);
            console.log('Current canvas objects before deletion:', canvas.getObjects().length);
            
            // Remove from plotsData - CRITICAL: This ensures deleted plots don't appear in other tabs
            const plotIndex = plotsData.findIndex(p => String(p.id || '') === String(plotId || ''));
            if (plotIndex > -1) {
                const removedPlot = plotsData.splice(plotIndex, 1)[0];
                console.log('‚úì Removed from plotsData:', removedPlot);
                console.log('Remaining plots in plotsData:', plotsData.length);
            } else {
                console.warn('‚ö†Ô∏è Plot not found in plotsData:', plotId);
                console.warn('Available plot IDs in plotsData:', plotsData.map(p => p.id));
            }
            
            // Remove circles (red dots) - works in both lines and points mode
            if (plotPoints[plotId]) {
                console.log('Removing', plotPoints[plotId].length, 'circles for plot:', plotId);
                plotPoints[plotId].forEach(circle => {
                    // Remove event handlers first to prevent any updates
                    try {
                        circle.off();
                    } catch (e) {
                        // Ignore if off() is not available
                    }
                    canvas.remove(circle);
                });
                delete plotPoints[plotId];
                console.log('‚úì Removed all circles');
            } else {
                console.warn('‚ö†Ô∏è No circles found for plot:', plotId, 'Available keys:', Object.keys(plotPoints));
            }
            
            // Remove polygon (red rectangle) - check regardless of mode
            // Polygons might exist even in points mode if user switched modes
            const polygonIndex = plotObjects.findIndex(p => {
                const matches = String(p.plotId || '') === String(plotId || '');
                if (!matches) {
                    console.log(`Polygon plotId="${p.plotId}" !== target="${plotId}"`);
                }
                return matches;
            });
            if (polygonIndex > -1) {
                const polygon = plotObjects[polygonIndex];
                console.log('‚úì Removing polygon (red rectangle)');
                // Remove event handlers first
                try {
                    polygon.off();
                } catch (e) {
                    // Ignore if off() is not available
                }
                canvas.remove(polygon);
                plotObjects.splice(polygonIndex, 1);
                console.log('‚úì Polygon removed from canvas and plotObjects array');
            } else {
                // Also check canvas objects directly in case polygon isn't in plotObjects
                const canvasObjects = canvas.getObjects();
                const polygonInCanvas = canvasObjects.find(obj => {
                    const isPolygon = (obj.points && Array.isArray(obj.points)) || obj.type === 'polygon';
                    return isPolygon && String(obj.plotId || '') === String(plotId || '');
                });
                if (polygonInCanvas) {
                    console.log('‚úì Found polygon in canvas (not in plotObjects), removing it');
                    try {
                        polygonInCanvas.off();
                    } catch (e) {
                        // Ignore if off() is not available
                    }
                    canvas.remove(polygonInCanvas);
                } else {
                    console.warn('‚ö†Ô∏è Polygon not found for plot:', plotId, 'Available plotIds:', plotObjects.map(p => p.plotId));
                }
            }
            
            // Remove plot number text
            let textRemoved = 0;
            canvas.getObjects().forEach(obj => {
                if (obj.type === 'text' && obj.plotId === plotId) {
                    canvas.remove(obj);
                    textRemoved++;
                }
            });
            if (textRemoved > 0) {
                console.log('‚úì Removed', textRemoved, 'text object(s)');
            }
            
            // Remove ALL objects with matching plotId (comprehensive cleanup)
            // This ensures nothing is left behind regardless of mode
            const allObjectsBefore = canvas.getObjects();
            let removedCount = 0;
            const objectsToRemove = [];
            
            allObjectsBefore.forEach(obj => {
                // Use string comparison to handle type mismatches
                if (String(obj.plotId || '') === String(plotId || '')) {
                    console.log('Removing remaining object:', obj.type || 'unknown', 'with plotId:', obj.plotId);
                    objectsToRemove.push(obj);
                    removedCount++;
                }
            });
            
            // Remove all found objects
            objectsToRemove.forEach(obj => {
                // Remove event handlers first
                try {
                    obj.off();
                } catch (e) {
                    // Ignore if off() is not available
                }
                canvas.remove(obj);
                
                // Also remove from plotObjects if it's a polygon
                if (obj.points || obj.type === 'polygon') {
                    const idx = plotObjects.findIndex(p => p === obj);
                    if (idx > -1) {
                        plotObjects.splice(idx, 1);
                        console.log('  - Also removed from plotObjects array');
                    }
                }
            });
            
            if (removedCount > 0) {
                console.log('‚úì Removed', removedCount, 'additional object(s) with plotId:', plotId);
            }
            
            // Force immediate render
            canvas.discardActiveObject();
            canvas.requestRenderAll();
            canvas.renderAll();
            
            // Store original plotId before any renumbering
            const originalPlotId = plotId;
            
            // CRITICAL: Final cleanup BEFORE renumbering to catch all objects with original plotId
            // Final check: Remove any remaining objects with deleted plotId
            // Run multiple passes to ensure everything is removed
            for (let pass = 1; pass <= 3; pass++) {
                const remainingObjects = canvas.getObjects().filter(obj => 
                    String(obj.plotId || '') === String(originalPlotId || '')
                );
                
                if (remainingObjects.length > 0) {
                    console.error(`‚ùå Pass ${pass}: Still found`, remainingObjects.length, 'objects with deleted plotId:', originalPlotId);
                    remainingObjects.forEach(obj => {
                        console.error('  - Removing object type:', obj.type || 'unknown', 'plotId:', obj.plotId);
                        
                        // Remove event handlers
                        try {
                            obj.off();
                        } catch (e) {
                            // Ignore
                        }
                        
                        // Multiple removal strategies
                        // Strategy 1: canvas.remove()
                        canvas.remove(obj);
                        
                        // Strategy 2: Remove by index from canvas objects array
                        const objIndex = canvas.getObjects().indexOf(obj);
                        if (objIndex > -1) {
                            canvas.getObjects().splice(objIndex, 1);
                            console.log('    Removed by array splice at index', objIndex);
                        }
                        
                        // Remove from plotObjects if it's a polygon
                        if (obj.points || obj.type === 'polygon') {
                            const idx = plotObjects.findIndex(p => p === obj);
                            if (idx > -1) {
                                plotObjects.splice(idx, 1);
                                console.log('    Removed from plotObjects array at index', idx);
                            }
                        }
                        
                        // Remove from plotPoints if it's a circle
                        if (obj.type === 'circle') {
                            Object.keys(plotPoints).forEach(key => {
                                const circles = plotPoints[key];
                                const circleIndex = circles.indexOf(obj);
                                if (circleIndex > -1) {
                                    circles.splice(circleIndex, 1);
                                    console.log('    Removed from plotPoints[' + key + '] at index', circleIndex);
                                    // If no circles left, remove the key
                                    if (circles.length === 0) {
                                        delete plotPoints[key];
                                    }
                                }
                            });
                        }
                    });
                    
                    // Force render after each pass
                    canvas.discardActiveObject();
                    canvas.requestRenderAll();
                    canvas.renderAll();
                } else {
                    console.log(`‚úÖ Pass ${pass}: All objects with plotId`, originalPlotId, 'successfully removed');
                    break; // Exit loop if all objects are removed
                }
            }
            
            // Final aggressive cleanup: Rebuild canvas if objects still remain
            const finalCheck = canvas.getObjects().filter(obj => 
                String(obj.plotId || '') === String(originalPlotId || '')
            );
            
            if (finalCheck.length > 0) {
                console.error('‚ùå CRITICAL: Objects still remain after 3 passes! Rebuilding canvas...');
                
                // Last resort: Complete canvas rebuild
                const bgImg = canvas.backgroundImage;
                const allObjects = canvas.getObjects();
                const objectsToKeep = allObjects.filter(obj => 
                    String(obj.plotId || '') !== String(originalPlotId || '')
                );
                
                console.log(`Rebuilding canvas: ${allObjects.length} ‚Üí ${objectsToKeep.length} objects`);
                canvas.clear();
                if (bgImg) {
                    canvas.setBackgroundImage(bgImg, () => {});
                }
                objectsToKeep.forEach(obj => canvas.add(obj));
                
                // Clean plotObjects array
                for (let i = plotObjects.length - 1; i >= 0; i--) {
                    if (String(plotObjects[i].plotId || '') === String(originalPlotId || '')) {
                        plotObjects.splice(i, 1);
                    }
                }
                
                // Clean plotPoints
                Object.keys(plotPoints).forEach(key => {
                    if (String(key || '') === String(originalPlotId || '')) {
                        delete plotPoints[key];
                    }
                });
                
                canvas.requestRenderAll();
                canvas.renderAll();
                console.log('‚úÖ Canvas rebuilt without deleted plot');
            } else {
                console.log('‚úÖ All objects with plotId', originalPlotId, 'successfully removed');
            }
            
            // Renumber all remaining plots sequentially (this will update plotPoints keys)
            // Do this AFTER final cleanup to ensure deleted plot is completely gone
            if (plotsData.length > 0) {
                renumberPlots();
            } else {
                console.log('No plots remaining, skipping renumbering');
            }
            
            selectedPlotForDelete = null;
            
            // Reset plot highlighting to default (all red, no selection)
            // Works for both lines and points mode
            if (mode === 'lines') {
                plotObjects.forEach(polygon => {
                    // Reset all polygons to red (unselected state)
                    polygon.set({ 
                        stroke: '#FF0000',  // Red color
                        strokeWidth: 2,
                        opacity: 0.7
                    });
                    polygon.setCoords();
                });
            }
            
            // Always reset circles (they exist in both modes)
            Object.values(plotPoints).flat().forEach(circle => {
                circle.set({ 
                    fill: '#FF0000',  // Red color
                    stroke: '#FFFFFF',
                    strokeWidth: 2
                });
                circle.setCoords();
            });
            
            // Ensure proper z-order after deletion
            ensureProperZOrder();
            canvas.discardActiveObject();
            canvas.requestRenderAll();
            canvas.renderAll();
            
            console.log('Final canvas objects after deletion:', canvas.getObjects().length);
            console.log('Plot deleted:', originalPlotId, '- All plots renumbered');
            
            // Show success message
            const deleteBtn = document.getElementById('delete-btn');
            if (deleteBtn) {
                deleteBtn.textContent = 'Delete';
                deleteBtn.style.backgroundColor = '#f44336';
            }
        }

        // Handle canvas resize
        function resizeCanvas() {
            const container = document.getElementById('canvas-container');
            if (!container) return;
            
            const containerWidth = Math.max(container.clientWidth - 20, 650);
            const containerHeight = Math.max(container.clientHeight - 20, 500);
            
            // CRITICAL: Update canvas dimensions to match DOM container size exactly
            // This ensures pointer calculations are accurate and fixes iframe resize issues
            canvas.setDimensions({
                width: containerWidth,
                height: containerHeight
            }, {
                backstoreOnly: false  // Update both backstore and frontstore
            });
            
            // CRITICAL: Ensure canvas element matches DOM container dimensions exactly
            const canvasElement = canvas.getElement();
            if (canvasElement) {
                canvasElement.width = containerWidth;
                canvasElement.height = containerHeight;
                canvasElement.style.width = containerWidth + 'px';
                canvasElement.style.height = containerHeight + 'px';
            }
            
            // CRITICAL: Recalculate offset to ensure pointer calculations respect zoom/pan
            // This must be called after any dimension change
            canvas.calcOffset();
            
            // CRITICAL: Update all object coordinates to ensure selection boxes align correctly
            canvas.getObjects().forEach(obj => {
                obj.setCoords();
            });
            
            canvas.renderAll();
        }

        // Wait for DOM to be ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', function() {
                setTimeout(resizeCanvas, 100);
            });
        } else {
            setTimeout(resizeCanvas, 100);
        }
        
        window.addEventListener('resize', resizeCanvas);
        
        // Canvas zoom functionality - zooms from center (FIXED: no more left drift!)
        function applyCanvasViewZoom(zoomLevel) {
            canvasViewZoom = Math.max(0.4, Math.min(5.0, zoomLevel)); // Expanded range: 0.4x to 5x
            
            // CRITICAL: Use canvas.zoomToPoint() instead of manually scaling objects
            // This ensures proper coordinate handling and prevents drift
            const centerPoint = new fabric.Point(canvas.width / 2, canvas.height / 2);
            canvas.zoomToPoint(centerPoint, canvasViewZoom);
            
            // CRITICAL: Recalculate canvas offset after zoom to ensure pointer calculations remain accurate
            canvas.calcOffset();
            
            // CRITICAL: Update all object coordinates to ensure selection boxes align correctly
            canvas.getObjects().forEach(obj => {
                obj.setCoords();
            });
            
            // Update zoom display
            const zoomValueEl = document.getElementById('zoom-value');
            const zoomHintEl = document.getElementById('zoom-hint');
            if (zoomValueEl) {
                zoomValueEl.textContent = canvasViewZoom.toFixed(1) + 'x';
            }
            
            // Update hint based on zoom level
            if (zoomHintEl) {
                if (canvasViewZoom > 1.0) {
                    zoomHintEl.innerHTML = '<strong style="color: #4CAF50;">‚úì Click & drag to pan!</strong><br>All layers move together';
                    zoomHintEl.style.color = '#4CAF50';
                } else {
                    zoomHintEl.innerHTML = 'Zooms entire canvas<br>All layers stay together';
                    zoomHintEl.style.color = '#999';
                }
            }
            
            canvas.renderAll();
        }
        
        function resetCanvasZoom() {
            canvasViewZoom = 1.0;
            
            // CRITICAL: Use canvas.setZoom() to reset zoom properly
            const centerPoint = new fabric.Point(canvas.width / 2, canvas.height / 2);
            canvas.zoomToPoint(centerPoint, 1.0);
            
            // CRITICAL: Recalculate canvas offset after zoom reset
            canvas.calcOffset();
            
            // CRITICAL: Update all object coordinates to ensure selection boxes align correctly
            canvas.getObjects().forEach(obj => {
                obj.setCoords();
            });
            
            const zoomValueEl = document.getElementById('zoom-value');
            const zoomHintEl = document.getElementById('zoom-hint');
            if (zoomValueEl) {
                zoomValueEl.textContent = '1.0x';
            }
            
            // Reset hint
            if (zoomHintEl) {
                zoomHintEl.innerHTML = 'Zooms entire canvas<br>All layers stay together';
                zoomHintEl.style.color = '#999';
            }
            
            canvas.renderAll();
        }
        
        // Event listeners for zoom buttons
        document.addEventListener('DOMContentLoaded', function() {
            const zoomInBtn = document.getElementById('zoom-in-btn');
            const zoomOutBtn = document.getElementById('zoom-out-btn');
            
            if (zoomInBtn) {
                zoomInBtn.addEventListener('click', function() {
                    applyCanvasViewZoom(canvasViewZoom + 0.1);
                });
            }
            
            if (zoomOutBtn) {
                zoomOutBtn.addEventListener('click', function() {
                    applyCanvasViewZoom(canvasViewZoom - 0.1);
                });
            }
        });
    </script>
</body>
</html>


